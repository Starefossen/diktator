[tools]
go = "1.25"
node = "24"
opentofu = "latest"
air = "latest"
pnpm = "10"

# ============================================================================
# Environment Configuration
# ============================================================================
[env]
# Static configuration - same across all environments
DIKTATOR_APP_NAME = "diktator"
DIKTATOR_API_SERVICE_NAME = "diktator-api"
DIKTATOR_DEFAULT_REGION = "europe-north1"
DIKTATOR_BUCKET_LOCATION = "EU"

# Development environment defaults
GOOGLE_CLOUD_PROJECT = "diktator-dev"
GOOGLE_CLOUD_QUOTA_PROJECT = "diktator-app"
STORAGE_BUCKET = "diktator-dev.appspot.com"
GIN_MODE = "debug"

# PostgreSQL configuration
DATABASE_URL = "postgresql://postgres:postgres@localhost:5432/diktator?sslmode=disable"
DATABASE_TEST_URL = "postgresql://postgres:postgres@localhost:5432/diktator_test?sslmode=disable"

# Authentication - mock mode for development
AUTH_MODE = "mock"

# Frontend configuration
NEXT_PUBLIC_API_URL = "http://localhost:8080"
NEXT_PUBLIC_AUTH_MODE = "mock"

# ============================================================================
# Development Tasks
# ============================================================================

[tasks.install]
description = "Install all dependencies"
run = [
    "cd frontend && pnpm install",
    "cd backend && go mod tidy",
    "go install github.com/swaggo/swag/cmd/swag@latest",
]

[tasks.dev]
description = "Start full development environment (PostgreSQL + frontend + backend)"
run = """
echo "üöÄ Starting full development environment..."

# Ensure config exists
if [ ! -f backend/.env.development ]; then
    echo "üìù Generating development config..."
    mise run config-dev
fi

# Ensure dependencies are installed
if [ ! -d frontend/node_modules ] || [ ! -f backend/go.sum ]; then
    echo "üì¶ Installing dependencies..."
    mise run install
fi

# Start PostgreSQL
echo "üêò Starting PostgreSQL..."
docker compose -f docker-compose.dev.yml up -d
sleep 3

# Run migrations
echo "üóÑÔ∏è  Running database migrations..."
mise run db:migrate

# Start backend with air (hot reload) in background
echo "üîß Starting backend with hot reload..."
cd backend && set -a && source .env.development && set +a && air &
BACKEND_PID=$!
sleep 3

# Check if backend started successfully
if ! kill -0 $BACKEND_PID 2>/dev/null; then
    echo "‚ùå Backend failed to start"
    exit 1
fi

echo "‚úÖ Backend started (PID: $BACKEND_PID)"

# Start frontend
echo "‚öõÔ∏è  Starting frontend..."
cd frontend && cp .env.development .env.local && pnpm run dev

# Cleanup on exit
cleanup() {
    echo ""
    echo "üõë Stopping services..."
    kill $BACKEND_PID 2>/dev/null || true
    docker compose -f docker-compose.dev.yml down
}
trap cleanup EXIT INT TERM
"""

[tasks."frontend:dev"]
description = "Start frontend development server"
run = """
if [ ! -f frontend/.env.development ]; then
    mise run config-dev
fi
cd frontend
cp .env.development .env.local
pnpm run dev
"""

[tasks."backend:dev"]
description = "Start backend with hot reload (air)"
run = """
if [ ! -f backend/.env.development ]; then
    mise run config-dev
fi
cd backend
set -a && source .env.development && set +a && air
"""

# ============================================================================
# Backend Service Management
# ============================================================================

[tasks."backend:start"]
description = "Start backend in background"
run = """
mkdir -p .tmp

if [ -f .tmp/backend.pid ] && kill -0 $(cat .tmp/backend.pid) 2>/dev/null; then
    echo "‚ö†Ô∏è  Backend already running (PID: $(cat .tmp/backend.pid))"
    exit 0
fi

if [ ! -f backend/.env.development ]; then
    mise run config-dev
fi

# Ensure PostgreSQL is running
if ! docker compose -f docker-compose.dev.yml ps postgres 2>/dev/null | grep -q "running"; then
    echo "üêò Starting PostgreSQL..."
    docker compose -f docker-compose.dev.yml up -d postgres
    sleep 3
fi

echo "üöÄ Starting backend..."
cd backend
set -a && source .env.development && set +a
nohup go run cmd/server/main.go > ../.tmp/backend.log 2>&1 &
echo $! > ../.tmp/backend.pid
cd ..

sleep 3
if kill -0 $(cat .tmp/backend.pid) 2>/dev/null; then
    echo "‚úÖ Backend started (PID: $(cat .tmp/backend.pid))"
    echo "   Logs: .tmp/backend.log"
    curl -s http://localhost:8080/health | head -c 100
    echo ""
else
    echo "‚ùå Backend failed to start"
    tail -20 .tmp/backend.log
    exit 1
fi
"""

[tasks."backend:stop"]
description = "Stop backend"
run = """
if [ -f .tmp/backend.pid ]; then
    PID=$(cat .tmp/backend.pid)
    if kill -0 $PID 2>/dev/null; then
        echo "Stopping backend (PID: $PID)..."
        kill $PID
        sleep 1
        kill -0 $PID 2>/dev/null && kill -9 $PID
        echo "‚úÖ Backend stopped"
    fi
    rm -f .tmp/backend.pid
else
    lsof -ti:8080 | xargs kill -9 2>/dev/null || true
fi
"""

[tasks."backend:logs"]
description = "View backend logs"
run = """
if [ -f .tmp/backend.log ]; then
    tail -f .tmp/backend.log
else
    echo "No log file found. Start backend with 'mise run backend:start'"
fi
"""

[tasks."backend:status"]
description = "Check backend status"
run = """
if [ -f .tmp/backend.pid ] && kill -0 $(cat .tmp/backend.pid) 2>/dev/null; then
    echo "‚úÖ Backend running (PID: $(cat .tmp/backend.pid))"
    curl -s http://localhost:8080/health 2>/dev/null || echo "‚ùå Not responding"
else
    echo "‚ùå Backend not running"
fi
"""

[tasks."backend:restart"]
description = "Restart backend"
run = "mise run backend:stop && sleep 1 && mise run backend:start"

# ============================================================================
# Database Tasks
# ============================================================================

[tasks."db:start"]
description = "Start PostgreSQL"
run = """
docker compose -f docker-compose.dev.yml up -d
echo "PostgreSQL started at localhost:5432"
"""

[tasks."db:stop"]
description = "Stop PostgreSQL"
run = "docker compose -f docker-compose.dev.yml down"

[tasks."db:reset"]
description = "Reset database (destroy and recreate)"
run = """
echo "WARNING: This will delete all data!"
read -p "Are you sure? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    docker compose -f docker-compose.dev.yml down -v
    docker compose -f docker-compose.dev.yml up -d
    sleep 3
    mise run db:migrate
fi
"""

[tasks."db:migrate"]
description = "Run database migrations"
run = """
echo "Running database migrations..."
for migration in migrations/*_*.up.sql; do
    if [ -f "$migration" ]; then
        echo "Applying $(basename "$migration") to diktator..."
        docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -d diktator < "$migration"
    fi
done
echo "‚úÖ All migrations completed."
"""

[tasks."db:migrate-test"]
description = "Run database migrations on test database"
run = """
echo "Running test database migrations..."
for migration in migrations/*_*.up.sql; do
    if [ -f "$migration" ]; then
        echo "Applying $(basename "$migration") to diktator_test..."
        docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -d diktator_test < "$migration"
    fi
done
echo "‚úÖ Test database migrations completed."
"""

[tasks."db:reset-test"]
description = "Reset test database (destroy and recreate)"
run = """
echo "Resetting test database..."
docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -c "DROP DATABASE IF EXISTS diktator_test;"
docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -c "CREATE DATABASE diktator_test;"
sleep 1
mise run db:migrate-test
echo "‚úÖ Test database reset complete."
"""

[tasks."db:shell"]
description = "Open PostgreSQL shell"
run = "docker compose -f docker-compose.dev.yml exec postgres psql -U postgres -d diktator"

[tasks."db:seed"]
description = "Seed database with test data"
run = """
echo "üå± Seeding database with test data..."
(cd backend && go run cmd/seed/main.go)
"""

[tasks."db:reset-seed"]
description = "Reset database and seed with fresh test data"
run = """
echo "üîÑ Resetting database..."
mise run db:reset

echo "‚è≥ Waiting for database..."
sleep 5

echo "üóÑÔ∏è  Running migrations..."
mise run db:migrate

echo "üå± Seeding test data..."
(cd backend && go run cmd/seed/main.go)

echo "‚úÖ Database reset and seeded!"
"""

# ============================================================================
# Code Quality
# ============================================================================

[tasks.lint]
description = "Run linters"
run = ["cd frontend && pnpm run lint", "cd backend && go vet ./..."]

[tasks.format]
description = "Format code"
run = [
    "cd frontend && pnpm run format",
    "cd backend && go fmt ./...",
    "mise run tofu:fmt",
]

[tasks.typecheck]
description = "Type check all code"
run = [
    "cd frontend && pnpm run typecheck",
    "cd backend && go build -o /dev/null ./...",
]

[tasks."frontend:knip"]
description = "Find unused code in frontend"
run = "cd frontend && pnpm run knip"

[tasks."frontend:knip-fix"]
description = "Auto-fix unused code in frontend"
run = "cd frontend && pnpm run knip:fix"

[tasks."frontend:check"]
description = "Run all frontend checks (typecheck, lint:fix, format, knip:fix, test) with auto-fixing"
run = "cd frontend && pnpm run check"

[tasks."frontend:build"]
description = "Build frontend for production"
run = """
cd frontend
cp .env.production .env.local 2>/dev/null || true
NODE_ENV=production pnpm run build
"""

[tasks."backend:check"]
description = "Run all backend checks (fmt, vet, test) with auto-fixing"
run = """
echo "üîß Running backend checks..."
echo ""
echo "üìù Formatting code..."
(cd backend && go fmt ./...)

echo ""
echo "üîç Running go vet..."
(cd backend && go vet ./...)

echo ""
echo "üß™ Running tests..."

if ! docker compose -f docker-compose.dev.yml ps postgres 2>/dev/null | grep -q "running"; then
    echo "üêò Starting PostgreSQL..."
    docker compose -f docker-compose.dev.yml up -d postgres
    sleep 3
fi

# Run migrations on test database
echo "üóÑÔ∏è  Running test database migrations..."
for migration in migrations/*_*.up.sql; do
    if [ -f "$migration" ]; then
        docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -d diktator_test < "$migration" 2>/dev/null || true
    fi
done

(cd backend && DATABASE_URL="${DATABASE_TEST_URL}" go test ./...)

echo ""
echo "‚úÖ All backend checks passed!"
"""

[tasks.test]
description = "Run all tests (backend + frontend unit tests)"
run = """
echo "üß™ Running all tests..."

# Ensure PostgreSQL is running
if ! docker compose -f docker-compose.dev.yml ps postgres 2>/dev/null | grep -q "running"; then
    echo "üêò Starting PostgreSQL..."
    docker compose -f docker-compose.dev.yml up -d postgres
    sleep 3
fi

echo ""
echo "üìã Running linters..."
mise run lint

echo ""
echo "üîç Type checking..."
mise run typecheck

echo ""
echo "üîß Backend tests..."
echo "üóÑÔ∏è  Preparing test database..."
for migration in migrations/*_*.up.sql; do
    if [ -f "$migration" ]; then
        docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -d diktator_test < "$migration" 2>/dev/null || true
    fi
done
(cd backend && DATABASE_URL="${DATABASE_TEST_URL}" go test ./...)

echo ""
echo "‚öõÔ∏è  Frontend unit tests..."
(cd frontend && pnpm test)

echo ""
echo "‚úÖ All tests passed!"
"""

[tasks.test-unit]
description = "Run unit tests only (skip integration tests)"
run = """
echo "üß™ Running unit tests..."

echo ""
echo "üîß Backend unit tests..."
(cd backend && go test -short ./...)

echo ""
echo "‚öõÔ∏è  Frontend unit tests..."
(cd frontend && pnpm test)

echo "‚úÖ Unit tests passed!"
"""

[tasks."backend:test"]
description = "Run backend tests"
run = """
echo "üîß Running backend tests..."

# Ensure PostgreSQL is running for integration tests
if ! docker compose -f docker-compose.dev.yml ps postgres 2>/dev/null | grep -q "running"; then
    echo "üêò Starting PostgreSQL..."
    docker compose -f docker-compose.dev.yml up -d postgres
    sleep 3
fi

# Run migrations on test database
echo "üóÑÔ∏è  Running test database migrations..."
for migration in migrations/*_*.up.sql; do
    if [ -f "$migration" ]; then
        docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -d diktator_test < "$migration" 2>/dev/null || true
    fi
done

(cd backend && DATABASE_URL="${DATABASE_TEST_URL}" go test -v ./...)
"""

[tasks."backend:test-short"]
description = "Run backend tests without integration tests"
run = "(cd backend && go test -short -v ./...)"

[tasks."backend:test-coverage"]
description = "Run backend tests with coverage"
run = """
echo "üîß Running backend tests with coverage..."

if ! docker compose -f docker-compose.dev.yml ps postgres 2>/dev/null | grep -q "running"; then
    echo "üêò Starting PostgreSQL..."
    docker compose -f docker-compose.dev.yml up -d postgres
    sleep 3
fi

# Run migrations on test database
for migration in migrations/*_*.up.sql; do
    if [ -f "$migration" ]; then
        docker compose -f docker-compose.dev.yml exec -T postgres psql -U postgres -d diktator_test < "$migration" 2>/dev/null || true
    fi
done

(cd backend && \
    DATABASE_URL="${DATABASE_TEST_URL}" go test -coverprofile=coverage.out ./... && \
    go tool cover -html=coverage.out -o coverage.html)
echo "‚úÖ Coverage report: backend/coverage.html"
"""

[tasks."frontend:test"]
description = "Run frontend unit tests"
run = "(cd frontend && pnpm test)"

[tasks."frontend:test-watch"]
description = "Run frontend tests in watch mode"
run = "(cd frontend && pnpm test:watch)"

[tasks."frontend:test-coverage"]
description = "Run frontend tests with coverage"
run = "(cd frontend && pnpm test:coverage)"

[tasks."frontend:test-e2e"]
description = "Run frontend E2E tests with Playwright"
run = """
echo "üé≠ Running E2E tests..."

# Check if backend is running
if ! curl -s http://localhost:8080/health > /dev/null 2>&1; then
    echo "‚ö†Ô∏è  Backend not running. Starting backend..."
    mise run backend:start
    sleep 5
fi

(cd frontend && pnpm test:e2e)
"""

[tasks."frontend:test-e2e-ui"]
description = "Run E2E tests with Playwright UI"
run = """
# Check if backend is running
if ! curl -s http://localhost:8080/health > /dev/null 2>&1; then
    echo "‚ö†Ô∏è  Backend not running. Starting backend..."
    mise run backend:start
    sleep 5
fi

(cd frontend && pnpm test:e2e:ui)
"""

[tasks.test-all]
description = "Run all tests including E2E"
run = """
echo "üß™ Running complete test suite..."

mise run test
echo ""
echo "üé≠ Running E2E tests..."
mise run frontend:test-e2e

echo ""
echo "‚úÖ All tests (unit + E2E) passed!"
"""

[tasks.check]
description = "Run all checks (backend + frontend: fmt, lint, typecheck, knip, tests)"
run = """
echo "üîç Running all checks..."
echo ""
echo "=== Backend Checks ==="
mise run backend:check

echo ""
echo "=== Frontend Checks ==="
mise run frontend:check

echo ""
echo "‚úÖ All checks passed!"
"""

[tasks.fmt]
description = "Format code (alias for format)"
run = "mise run format"

# ============================================================================
# API Documentation
# ============================================================================

[tasks."backend:swagger-gen"]
description = "Generate OpenAPI spec"
run = """
cd backend
command -v swag &>/dev/null || go install github.com/swaggo/swag/cmd/swag@latest
swag init -g cmd/server/main.go --output docs --parseInternal
echo "‚úÖ OpenAPI spec generated"
"""

[tasks."frontend:client-gen"]
description = "Generate TypeScript client"
run = """
cd frontend
npx @openapitools/openapi-generator-cli generate \
    -i ../backend/docs/swagger.json \
    -g typescript-axios \
    -o src/generated \
    --additional-properties=supportsES6=true,withInterfaces=true
echo "‚úÖ TypeScript client generated"
"""

# ============================================================================
# Build Tasks
# ============================================================================

[tasks.build]
description = "Build for production"
run = [
    "mise run backend:swagger-gen",
    "mise run config-prod",
    "cd frontend && cp .env.production .env.local && pnpm run build",
    "cd backend && go build -o bin/server cmd/server/main.go",
]

[tasks."backend:build-binary"]
description = "Build backend binary for target architecture"
run = """
ARCH=${TARGETARCH:-amd64}
echo "üî® Building backend binary for linux-${ARCH}..."
mkdir -p backend/bin
cd backend
CGO_ENABLED=0 GOOS=linux GOARCH=${ARCH} go build -ldflags="-w -s" -o bin/server-linux-${ARCH} ./cmd/server/main.go
echo "‚úÖ Binary built: backend/bin/server-linux-${ARCH}"
"""

[tasks."backend:docker-build"]
description = "Build backend Docker image (builds binary first)"
run = """
ARCH=${TARGETARCH:-amd64}
echo "üì¶ Building backend Docker image for ${ARCH}..."

# Build binary outside Docker for performance
mise run backend:build-binary

# Build minimal Docker image with pre-built binary
cd backend
docker build --build-arg TARGETARCH=${ARCH} -t diktator-api:latest -t diktator-api:${ARCH} .
echo "‚úÖ Built: diktator-api:latest (linux-${ARCH})"
"""

[tasks."frontend:docker-build"]
description = "Build frontend Docker image with nginx"
run = """
echo "üì¶ Building frontend Docker image..."

# Build frontend first
cd frontend
cp .env.production .env.local 2>/dev/null || true
NODE_ENV=production pnpm run build

# Build minimal Docker image with nginx
docker build -t diktator-frontend:latest .
echo "‚úÖ Built: diktator-frontend:latest"
"""

[tasks.clean]
description = "Clean build artifacts"
run = [
    "mise run backend:stop 2>/dev/null || true",
    "rm -rf frontend/.next frontend/out frontend/src/generated frontend/dist",
    "rm -rf backend/bin",
    "rm -f frontend/.env.local backend/.env.* frontend/.env.*",
    "rm -f .mise.env",
    "rm -rf .tmp",
]

# ============================================================================
# Setup & Configuration
# ============================================================================

[tasks.setup]
description = "Initial project setup"
run = """
echo "üöÄ Setting up Diktator..."

echo ""
echo "üì¶ Installing tools..."
mise install

echo ""
echo "üìù Generating development config..."
mise run config-dev

echo ""
echo "üì¶ Installing dependencies..."
mise run install

echo ""
echo "üêò Starting PostgreSQL..."
docker compose -f docker-compose.dev.yml pull
docker compose -f docker-compose.dev.yml up -d
sleep 3

echo ""
echo "üóÑÔ∏è  Running database migrations..."
mise run db:migrate

echo ""
echo "‚úÖ Setup complete!"
echo ""
echo "Next steps:"
echo "  Start full dev:     mise run dev"
echo "  Start backend only: mise run backend:start"
echo "  Start frontend:     mise run frontend:dev"
echo "  Run tests:          mise run test"
"""

[tasks.config-dev]
description = "Generate development configuration"
run = """
cat > backend/.env.development << 'EOF'
# Backend Development Configuration
GOOGLE_CLOUD_PROJECT=diktator-dev
GOOGLE_CLOUD_QUOTA_PROJECT=diktator-app
STORAGE_BUCKET=diktator-dev.appspot.com
GIN_MODE=debug
PORT=8080
DATABASE_URL=postgresql://postgres:postgres@localhost:5432/diktator?sslmode=disable
DATABASE_TEST_URL=postgresql://postgres:postgres@localhost:5432/diktator_test?sslmode=disable
AUTH_MODE=mock
EOF

cat > frontend/.env.development << 'EOF'
# Frontend Development Configuration
NEXT_PUBLIC_API_URL=http://localhost:8080
NEXT_PUBLIC_AUTH_MODE=mock
NEXT_TELEMETRY_DISABLED=1
NODE_ENV=development
EOF

echo "‚úÖ Development config created"
"""

[tasks.config-prod]
description = "Generate production configuration"
run = """
if [ ! -f .mise.env ]; then
    echo "ERROR: .mise.env not found. Run 'mise run config-load' first."
    exit 1
fi
source .mise.env

cat > backend/.env.production << EOF
GOOGLE_CLOUD_PROJECT=${DIKTATOR_PROJECT_ID}
GOOGLE_CLOUD_QUOTA_PROJECT=${GOOGLE_CLOUD_QUOTA_PROJECT:-${DIKTATOR_PROJECT_ID}}
STORAGE_BUCKET=${STORAGE_BUCKET:-${DIKTATOR_PROJECT_ID}.appspot.com}
GIN_MODE=release
PORT=8080
DATABASE_URL=${DATABASE_URL}
AUTH_MODE=oidc
OIDC_ISSUER_URL=${OIDC_ISSUER_URL:-https://auth.diktator.app}
OIDC_AUDIENCE=${OIDC_AUDIENCE:-diktator}
EOF

cat > frontend/.env.production << EOF
NEXT_PUBLIC_API_URL=${DIKTATOR_API_URL:-https://${DIKTATOR_API_SERVICE_NAME}-${DIKTATOR_REGION:-${DIKTATOR_DEFAULT_REGION}}.run.app}
NEXT_PUBLIC_AUTH_MODE=oidc
NEXT_PUBLIC_OIDC_ISSUER_URL=${OIDC_ISSUER_URL:-https://auth.diktator.app}
NEXT_PUBLIC_OIDC_CLIENT_ID=${OIDC_CLIENT_ID:-diktator-frontend}
NEXT_TELEMETRY_DISABLED=1
NODE_ENV=production
EOF

echo "‚úÖ Production config created"
"""

[tasks.config-load]
description = "Load configuration from terraform"
run = """
cd terraform
if [ ! -d .terraform ]; then
    echo "Terraform not initialized. Run 'mise run tofu:init'"
    exit 1
fi

cat > ../.mise.env << EOF
DIKTATOR_PROJECT_ID=$(tofu output -raw project_id 2>/dev/null || echo "")
DIKTATOR_REGION=$(tofu output -raw region 2>/dev/null || echo "${DIKTATOR_DEFAULT_REGION}")
DIKTATOR_FRONTEND_BUCKET=$(tofu output -raw frontend_bucket_name 2>/dev/null || echo "")
DIKTATOR_API_URL=$(tofu output -raw api_url 2>/dev/null || echo "")
DATABASE_URL=$(tofu output -raw database_url 2>/dev/null || echo "")
EOF
echo "Configuration loaded to .mise.env"
"""

[tasks.config-check]
description = "Check configuration"
run = """
echo "=== Static Config ==="
echo "App: ${DIKTATOR_APP_NAME}"
echo "Region: ${DIKTATOR_DEFAULT_REGION}"

echo ""
echo "=== Development Config ==="
[ -f backend/.env.development ] && cat backend/.env.development || echo "‚ùå Not found"

echo ""
echo "=== Production Config ==="
[ -f .mise.env ] && cat .mise.env || echo "‚ùå Not found (run 'mise run config-load')"
"""

# ============================================================================
# Infrastructure (OpenTofu)
# ============================================================================

[tasks."tofu:init"]
description = "Initialize OpenTofu"
run = "cd terraform && tofu init"

[tasks."tofu:plan"]
description = "Plan infrastructure changes"
run = "cd terraform && tofu plan"

[tasks."tofu:apply"]
description = "Apply infrastructure"
run = "cd terraform && tofu apply"

[tasks."tofu:destroy"]
description = "Destroy infrastructure"
run = "cd terraform && tofu destroy"

[tasks."tofu:fmt"]
description = "Format terraform files"
run = "cd terraform && tofu fmt"

# ============================================================================
# Deployment
# ============================================================================

[tasks."backend:deploy"]
description = "Deploy backend to Cloud Run"
run = """
source .mise.env
mise run config-prod

cd backend
docker buildx build --platform linux/amd64 -t gcr.io/${DIKTATOR_PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:latest --load .
docker push gcr.io/${DIKTATOR_PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:latest

gcloud run deploy ${DIKTATOR_API_SERVICE_NAME} \
  --image gcr.io/${DIKTATOR_PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:latest \
  --region ${DIKTATOR_REGION} \
  --platform managed \
  --allow-unauthenticated
"""

[tasks."frontend:deploy"]
description = "Deploy frontend to Cloud Storage"
run = """
source .mise.env
mise run config-prod

cd frontend
rm -rf out
cp .env.production .env.local
pnpm run build

gsutil -m cp -r out/* gs://${DIKTATOR_FRONTEND_BUCKET}/
gsutil -m setmeta -h "Cache-Control:no-cache" gs://${DIKTATOR_FRONTEND_BUCKET}/*.html
gsutil -m setmeta -h "Cache-Control:public, max-age=31536000" gs://${DIKTATOR_FRONTEND_BUCKET}/_next/static/**/*
"""

# ============================================================================
# CI/CD
# ============================================================================

[tasks."ci:test"]
description = "CI: Run all tests"
run = [
    "cd frontend && pnpm ci && pnpm run lint && pnpm run typecheck",
    "cd backend && go mod tidy && go test ./... && go vet ./...",
]

[tasks."ci:build-backend"]
description = "CI: Build backend image"
run = """
PROJECT_ID=${GOOGLE_CLOUD_PROJECT:-${DIKTATOR_PROJECT_ID}}
COMMIT_SHA=${GITHUB_SHA:-latest}
cd backend
docker buildx build --platform linux/amd64 -t gcr.io/${PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:${COMMIT_SHA} --load .
docker push gcr.io/${PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:${COMMIT_SHA}
"""

[tasks."ci:build-frontend"]
description = "CI: Build frontend"
run = """
cd frontend
pnpm ci
cp .env.production .env.local 2>/dev/null || true
pnpm run build
"""

# ============================================================================
# Google Cloud
# ============================================================================

[tasks."gcloud:auth"]
description = "Authenticate with Google Cloud"
run = "gcloud auth login && gcloud auth application-default login"

[tasks."gcloud:set-project"]
description = "Set GCP project"
run = """
if [ -z "$1" ]; then
  echo "Usage: mise run gcloud:set-project -- PROJECT_ID"
  exit 1
fi
gcloud config set project "$1"
"""

# ============================================================================
# Homelab Deployment (Knative)
# ============================================================================

[tasks."homelab:build-backend"]
description = "Build backend binaries and Docker image for homelab"
run = """
  echo "üî® Building backend binaries..."
  cd backend

  # Build for linux/amd64
  CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/server-linux-amd64 ./cmd/server

  # Build for linux/arm64
  CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o bin/server-linux-arm64 ./cmd/server

  echo "üì¶ Building and pushing Docker image..."
  BUILD_TAG=$(date +%s)
  REGISTRY_URL=${REGISTRY_URL:-registry.intern.flaatten.org:5000}
  SERVICE_NAME=${BACKEND_SERVICE:-api}

  # Build multi-arch image
  docker buildx build \
    --platform linux/amd64,linux/arm64 \
    --build-arg TARGETARCH=amd64 \
    -t ${REGISTRY_URL}/${SERVICE_NAME}:${BUILD_TAG} \
    --push \
    .

  # Save build tag for deployment
  echo ${BUILD_TAG} > ../.build-tag-backend
  echo "‚úÖ Backend built: ${REGISTRY_URL}/${SERVICE_NAME}:${BUILD_TAG}"
"""

[tasks."homelab:install-frontend"]
description = "Install frontend dependencies"
run = """
  cd frontend
  echo "üì¶ Installing frontend dependencies..."
  pnpm install
"""

[tasks."homelab:build-frontend"]
description = "Build frontend and Docker image for homelab"
depends = ["homelab:install-frontend"]
run = """
  echo "üî® Building frontend static files..."
  cd frontend
  # Set production API URL for static export
  export NEXT_PUBLIC_API_URL="https://api.diktator.fn.flaatten.org"
  export NEXT_PUBLIC_AUTH_MODE="oidc"
  pnpm run build

  echo "üì¶ Building and pushing Docker image..."
  BUILD_TAG=$(date +%s)
  REGISTRY_URL=${REGISTRY_URL:-registry.intern.flaatten.org:5000}
  SERVICE_NAME=${FRONTEND_SERVICE:-www}

  # Build multi-arch image
  docker buildx build \
    --platform linux/amd64,linux/arm64 \
    -t ${REGISTRY_URL}/${SERVICE_NAME}:${BUILD_TAG} \
    --push \
    .

  # Save build tag for deployment
  echo ${BUILD_TAG} > ../.build-tag-frontend
  echo "‚úÖ Frontend built: ${REGISTRY_URL}/${SERVICE_NAME}:${BUILD_TAG}"
"""

[tasks."homelab:build"]
description = "Build both backend and frontend for homelab"
depends = ["homelab:build-backend", "homelab:build-frontend"]

[tasks."homelab:gcp-export-credentials"]
description = "Export Google Cloud credentials from Terraform"
run = """
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  echo "üì• Exporting Google Cloud credentials..."

  if [ ! -d "terraform/.terraform" ]; then
    echo "‚ùå Terraform not initialized. Run 'mise run tofu:init' first."
    exit 1
  fi

  cd terraform
  if ! tofu output app_service_account_key >/dev/null 2>&1; then
    echo "‚ùå No service account found. Run 'mise run tofu:apply' first."
    exit 1
  fi

  tofu output -raw app_service_account_key | base64 -d > ../${DEPLOY_DIR}/gcp-credentials.json
  echo "‚úÖ Credentials exported to ${DEPLOY_DIR}/gcp-credentials.json"
"""

[tasks."homelab:gcp-create-secret"]
description = "Create Kubernetes secret for Google Cloud credentials"
depends = ["homelab:create-namespace", "homelab:gcp-export-credentials"]
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  if [ ! -f "${DEPLOY_DIR}/gcp-credentials.json" ]; then
    echo "‚ùå Credentials file not found. Run 'mise run homelab:gcp-export-credentials' first."
    exit 1
  fi

  echo "üîê Creating Kubernetes secret..."

  # Delete existing secret if it exists
  kubectl delete secret gcp-credentials -n ${NAMESPACE} 2>/dev/null || true

  # Create new secret
  kubectl create secret generic gcp-credentials \
    --from-file=key.json=${DEPLOY_DIR}/gcp-credentials.json \
    -n ${NAMESPACE}

  # Delete credentials file from disk
  rm -f ${DEPLOY_DIR}/gcp-credentials.json

  echo "‚úÖ Secret 'gcp-credentials' created in namespace ${NAMESPACE}"
  echo "üóëÔ∏è  Credentials file removed from disk"
"""

[tasks."homelab:create-namespace"]
description = "Create namespace if it doesn't exist"
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  if ! kubectl get namespace ${NAMESPACE} >/dev/null 2>&1; then
    kubectl create namespace ${NAMESPACE}
    echo "‚úÖ Created namespace: ${NAMESPACE}"
  else
    echo "‚úì Namespace ${NAMESPACE} already exists"
  fi
"""

[tasks."homelab:apply-network-policies"]
description = "Apply Cilium network policies"
depends = ["homelab:create-namespace"]
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  echo "üîí Applying network policies..."
  kubectl apply -f ${DEPLOY_DIR}/networkpolicy.yaml

  echo "‚úÖ Network policies applied"
"""

[tasks."homelab:deploy-backend"]
description = "Deploy backend to Knative"
depends = ["homelab:gcp-create-secret"]
run = """
  if [ ! -f ".build-tag-backend" ]; then
    echo "‚ùå No build tag found. Run 'mise run homelab:build-backend' first."
    exit 1
  fi

  BUILD_TAG=$(cat .build-tag-backend)
  REGISTRY_URL=${REGISTRY_URL:-registry.intern.flaatten.org:5000}
  SERVICE_NAME=${BACKEND_SERVICE:-api}
  NAMESPACE=${NAMESPACE:-diktator}
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  echo "üöÄ Deploying backend: ${SERVICE_NAME}:${BUILD_TAG}"

  # Update image tag in manifest
  sed "s|BUILD_TAG|${BUILD_TAG}|" \
    ${DEPLOY_DIR}/knative-service-backend.yaml | kubectl apply -f -

  echo "‚è≥ Waiting for backend to be ready..."
  kubectl wait --for=condition=Ready \
    --timeout=300s \
    -n ${NAMESPACE} \
    ksvc/${SERVICE_NAME}

  echo "‚úÖ Backend deployed successfully"
"""

[tasks."homelab:deploy-frontend"]
description = "Deploy frontend to Knative"
run = """
  if [ ! -f ".build-tag-frontend" ]; then
    echo "‚ùå No build tag found. Run 'mise run homelab:build-frontend' first."
    exit 1
  fi

  BUILD_TAG=$(cat .build-tag-frontend)
  REGISTRY_URL=${REGISTRY_URL:-registry.intern.flaatten.org:5000}
  SERVICE_NAME=${FRONTEND_SERVICE:-www}
  NAMESPACE=${NAMESPACE:-diktator}
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  echo "üöÄ Deploying frontend: ${SERVICE_NAME}:${BUILD_TAG}"

  # Update image tag in manifest
  sed "s|BUILD_TAG|${BUILD_TAG}|" \
    ${DEPLOY_DIR}/knative-service-frontend.yaml | kubectl apply -f -

  echo "‚è≥ Waiting for frontend to be ready..."
  kubectl wait --for=condition=Ready \
    --timeout=300s \
    -n ${NAMESPACE} \
    ksvc/${SERVICE_NAME}

  echo "‚úÖ Frontend deployed successfully"
"""

[tasks."homelab:deploy"]
description = "Deploy both backend and frontend to homelab"
depends = [
    "homelab:create-namespace",
    "homelab:gcp-create-secret",
    "homelab:apply-network-policies",
    "homelab:db-migrate",
    "homelab:deploy-backend",
    "homelab:deploy-frontend",
]

[tasks."homelab:full-deploy"]
description = "Build and deploy both services to homelab"
depends = ["homelab:build", "homelab:deploy"]

[tasks."homelab:db-create"]
description = "Create PostgreSQL database"
depends = ["homelab:create-namespace"]
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  echo "üìä Creating database..."
  kubectl apply -f ${DEPLOY_DIR}/postgres-cluster.yaml

  echo "‚è≥ Waiting for database to be ready..."
  kubectl wait --for=condition=Ready \
    --timeout=300s \
    -n ${NAMESPACE} \
    cluster/diktator-db

  echo "‚úÖ Database created successfully"
"""

[tasks."homelab:db-migrate"]
description = "Run database migrations"
depends = ["homelab:db-create"]
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}

  echo "üóÑÔ∏è  Running database migrations..."
  kubectl apply -f ${DEPLOY_DIR}/migration-job.yaml

  echo "‚è≥ Waiting for migration to complete..."
  kubectl wait --for=condition=complete \
    --timeout=300s \
    -n ${NAMESPACE} \
    job/diktator-migrate

  echo "‚úÖ Database migrations completed"
"""

[tasks."homelab:status"]
description = "Show status of all services"
run = """
  NAMESPACE=${NAMESPACE:-diktator}

  echo "=== Knative Services ==="
  kubectl get ksvc -n ${NAMESPACE}
  echo ""
  echo "=== PostgreSQL Cluster ==="
  kubectl get cluster -n ${NAMESPACE}
  echo ""
  echo "=== Pods ==="
  kubectl get pods -n ${NAMESPACE}
"""

[tasks."homelab:logs-backend"]
description = "View backend logs"
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  SERVICE_NAME=${BACKEND_SERVICE:-api}
  kubectl logs -n ${NAMESPACE} -l serving.knative.dev/service=${SERVICE_NAME} --tail=100 -f
"""

[tasks."homelab:logs-frontend"]
description = "View frontend logs"
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  SERVICE_NAME=${FRONTEND_SERVICE:-www}
  kubectl logs -n ${NAMESPACE} -l serving.knative.dev/service=${SERVICE_NAME} --tail=100 -f
"""

[tasks."homelab:url-backend"]
description = "Get backend URL"
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  SERVICE_NAME=${BACKEND_SERVICE:-api}
  kn service describe ${SERVICE_NAME} -n ${NAMESPACE} -o url
"""

[tasks."homelab:url-frontend"]
description = "Get frontend URL"
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  SERVICE_NAME=${FRONTEND_SERVICE:-www}
  kn service describe ${SERVICE_NAME} -n ${NAMESPACE} -o url
"""

[tasks."homelab:delete-backend"]
description = "Delete backend service"
run = """
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}
  kubectl delete -f ${DEPLOY_DIR}/knative-service-backend.yaml
"""

[tasks."homelab:delete-frontend"]
description = "Delete frontend service"
run = """
  DEPLOY_DIR=${DEPLOY_DIR:-deploy}
  kubectl delete -f ${DEPLOY_DIR}/knative-service-frontend.yaml
"""

[tasks."homelab:delete"]
description = "Delete all services"
run = """
  NAMESPACE=${NAMESPACE:-diktator}
  kubectl delete ksvc -n ${NAMESPACE} --all
  echo "‚úÖ All services deleted"
  echo "üí° To delete namespace: kubectl delete namespace ${NAMESPACE}"
"""

[tasks."homelab:clean"]
description = "Clean build artifacts"
run = """
  rm -f .build-tag-backend .build-tag-frontend
  rm -rf backend/bin
  rm -rf frontend/out frontend/.next
  echo "‚úÖ Build artifacts cleaned"
"""
