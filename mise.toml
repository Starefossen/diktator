[tools]
node = "20"
go = "1.21"
opentofu = "latest"
firebase = "latest"

# Environment configurations
[env]
# Static configuration - defaults for all environments
DIKTATOR_APP_NAME = "diktator"
DIKTATOR_API_SERVICE_NAME = "diktator-api"
DIKTATOR_DEFAULT_REGION = "europe-north1"
DIKTATOR_DEFAULT_PORT = "8080"
DIKTATOR_BUCKET_LOCATION = "EU"

# Development environment defaults
NODE_ENV = "development"
GOOGLE_CLOUD_PROJECT = "diktator-dev"

# Next.js development defaults
NEXT_PUBLIC_API_URL = "http://localhost:8080"

# Firebase Emulator configuration for local development
NEXT_PUBLIC_FIREBASE_USE_EMULATOR = "true"
FIREBASE_AUTH_EMULATOR_HOST = "localhost:9099"
FIRESTORE_EMULATOR_HOST = "localhost:8088"

# Core development tasks
[tasks.install]
description = "Install all dependencies"
run = ["cd frontend && npm install", "cd backend && go mod tidy"]

[tasks.dev]
description = "Start full development environment (Firebase emulators + frontend + backend)"
run = """
echo "Starting full development environment..."
echo "This will start:"
echo "  - Firebase emulators (Auth: :9099, Firestore: :8088, UI: :4000)"
echo "  - Frontend dev server (:3000)"
echo "  - Backend API server (:8080)"
echo ""

# Start Firebase emulators in background
mise run firebase-emulators &
FIREBASE_PID=$!
echo "Firebase emulators started with PID: $FIREBASE_PID"

# Wait for Firebase emulators to start
sleep 3

# Start backend in background
cd backend && go run cmd/server/main.go &
BACKEND_PID=$!
echo "Backend started with PID: $BACKEND_PID"

# Wait a moment for backend to start
sleep 2

# Start frontend (this will block)
cd frontend && npm run dev

# Cleanup function
cleanup() {
    echo "Stopping services..."
    kill $FIREBASE_PID 2>/dev/null || true
    kill $BACKEND_PID 2>/dev/null || true
}
trap cleanup EXIT
"""

[tasks.frontend]
description = "Start frontend development server only"
run = "cd frontend && npm run dev"

[tasks.backend]
description = "Start backend development server only"
run = "cd backend && go run cmd/server/main.go"

# Quality assurance tasks
[tasks.lint]
description = "Run linting for all components"
run = ["cd frontend && npm run lint", "cd backend && go vet ./..."]

[tasks.format]
description = "Format all code"
run = [
  "cd frontend && npm run format",
  "cd backend && go fmt ./...",
  "mise run tofu-fmt",
]

[tasks.typecheck]
description = "Run type checking for all components"
run = [
  "cd frontend && npm run typecheck",
  "cd backend && go build -o /dev/null ./...",
]

[tasks.test]
description = "Run all tests and checks"
run = ["mise run lint", "mise run typecheck", "cd backend && go test ./..."]

# Build tasks
[tasks.build]
description = "Build all components for production"
run = [
  "cd frontend && npm run build",
  "cd backend && go build -o bin/server cmd/server/main.go",
]

[tasks.clean]
description = "Clean build artifacts"
run = ["rm -rf frontend/.next frontend/out", "rm -rf backend/bin"]

# Infrastructure tasks
[tasks.tofu-init]
description = "Initialize OpenTofu"
run = "cd terraform && tofu init"

[tasks.tofu-plan]
description = "Plan OpenTofu deployment"
run = "cd terraform && tofu plan"

[tasks.tofu-apply]
description = "Apply OpenTofu configuration"
run = "cd terraform && tofu apply"

[tasks.tofu-destroy]
description = "Destroy OpenTofu infrastructure"
run = "cd terraform && tofu destroy"

[tasks.tofu-fmt]
description = "Format OpenTofu configuration files"
run = "cd terraform && tofu fmt"

[tasks.tofu-validate]
description = "Validate OpenTofu configuration"
run = "cd terraform && tofu validate"

# Setup and utility tasks
[tasks.setup]
description = "Complete setup for local development (run this first!)"
run = "./scripts/setup-dev.sh"

# Docker tasks
[tasks.docker-build]
description = "Build Docker image locally"
run = """
cd backend
docker build -t diktator-api:local .
echo "Docker image built: diktator-api:local"
"""

[tasks.docker-run]
description = "Run backend Docker container locally"
run = """
docker run -p 8080:8080 -e GOOGLE_CLOUD_PROJECT=${GOOGLE_CLOUD_PROJECT:-diktator-dev} diktator-api:local
"""

# CI/CD tasks
[tasks.ci-test]
description = "Run all tests for CI (both frontend and backend)"
run = [
  "cd frontend && npm ci && npm run lint && npm run typecheck",
  "cd backend && go mod tidy && go test ./... && go vet ./...",
]

[tasks.ci-build-backend]
description = "Build backend for CI/CD"
run = """
PROJECT_ID=${GOOGLE_CLOUD_PROJECT:-${DIKTATOR_PROJECT_ID}}
COMMIT_SHA=${GITHUB_SHA:-latest}
SERVICE_NAME=${DIKTATOR_API_SERVICE_NAME}

if [ -z "$PROJECT_ID" ]; then
  echo "Error: GOOGLE_CLOUD_PROJECT not set"
  exit 1
fi

cd backend
echo "Building Docker image: gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${COMMIT_SHA}"
docker buildx build --platform linux/amd64 --build-arg TARGETOS=linux --build-arg TARGETARCH=amd64 -t gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${COMMIT_SHA} --load .
docker push gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${COMMIT_SHA}
"""

[tasks.ci-build-frontend]
description = "Build frontend for CI/CD"
run = """
cd frontend
npm ci
export NODE_ENV=production
npm run build
"""

[tasks.ci-deploy-backend]
description = "Deploy backend for CI/CD"
run = """
PROJECT_ID=${GOOGLE_CLOUD_PROJECT:-${DIKTATOR_PROJECT_ID}}
COMMIT_SHA=${GITHUB_SHA:-latest}
SERVICE_NAME=${DIKTATOR_API_SERVICE_NAME}
REGION=${GCP_REGION:-${DIKTATOR_DEFAULT_REGION}}

if [ -z "$PROJECT_ID" ]; then
  echo "Error: GOOGLE_CLOUD_PROJECT not set"
  exit 1
fi

echo "Deploying backend: gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${COMMIT_SHA} to region: ${REGION}"
gcloud run deploy ${SERVICE_NAME} \
  --image gcr.io/${PROJECT_ID}/${SERVICE_NAME}:${COMMIT_SHA} \
  --region ${REGION} \
  --platform managed \
  --allow-unauthenticated \
  --set-env-vars="GOOGLE_CLOUD_PROJECT=${PROJECT_ID}"
"""

[tasks.ci-deploy-frontend]
description = "Deploy frontend for CI/CD"
run = """
gsutil -m cp -r frontend/out/* gs://${GCP_FRONTEND_BUCKET}/
echo "Setting cache headers for deployed files..."
gsutil -m setmeta -h "Cache-Control:no-cache, no-store, must-revalidate" -h "Pragma:no-cache" -h "Expires:0" gs://${GCP_FRONTEND_BUCKET}/index.html
gsutil -m setmeta -h "Cache-Control:public, max-age=300" gs://${GCP_FRONTEND_BUCKET}/**/*.html
gsutil -m setmeta -h "Cache-Control:no-cache, no-store, must-revalidate" -h "Pragma:no-cache" -h "Expires:0" gs://${GCP_FRONTEND_BUCKET}/index.html
gsutil -m setmeta -h "Cache-Control:public, max-age=31536000" gs://${GCP_FRONTEND_BUCKET}/**/*.{js,css,png,jpg,jpeg,gif,ico,svg}
echo "Invalidating CDN cache for key routes..."
PROJECT_ID=${GOOGLE_CLOUD_PROJECT:-${GCP_PROJECT_ID}}
gcloud compute url-maps invalidate-cdn-cache ${PROJECT_ID}-frontend-url-map --path="/" --async || echo "Cache invalidation failed for /"
gcloud compute url-maps invalidate-cdn-cache ${PROJECT_ID}-frontend-url-map --path="/practice" --async || echo "Cache invalidation failed for /practice"
gcloud compute url-maps invalidate-cdn-cache ${PROJECT_ID}-frontend-url-map --path="/practice/" --async || echo "Cache invalidation failed for /practice/"
gcloud compute url-maps invalidate-cdn-cache ${PROJECT_ID}-frontend-url-map --path="/about" --async || echo "Cache invalidation failed for /about"
gcloud compute url-maps invalidate-cdn-cache ${PROJECT_ID}-frontend-url-map --path="/about/" --async || echo "Cache invalidation failed for /about/"
echo "CDN cache invalidation initiated"
"""

# Deployment tasks for local development
[tasks.deploy-backend]
description = "Deploy backend to Cloud Run (local development)"
run = """
mise run config-load
source .mise.env
cd backend
docker buildx build --platform linux/amd64 -t gcr.io/${DIKTATOR_PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:latest --load .
docker push gcr.io/${DIKTATOR_PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:latest
gcloud run deploy ${DIKTATOR_API_SERVICE_NAME} \
  --image gcr.io/${DIKTATOR_PROJECT_ID}/${DIKTATOR_API_SERVICE_NAME}:latest \
  --region ${DIKTATOR_REGION} \
  --platform managed \
  --allow-unauthenticated \
  --set-env-vars="GOOGLE_CLOUD_PROJECT=${DIKTATOR_PROJECT_ID}"
"""

[tasks.deploy-frontend]
description = "Deploy frontend to Cloud Storage (local development)"
run = """
mise run config-load
source .mise.env
cd frontend
mise run env-production
npm run build
gsutil -m cp -r out/* gs://${DIKTATOR_FRONTEND_BUCKET}/
# Cache headers and CDN invalidation
gsutil -m setmeta -h "Cache-Control:no-cache" gs://${DIKTATOR_FRONTEND_BUCKET}/index.html
gsutil -m setmeta -h "Cache-Control:public, max-age=31536000" gs://${DIKTATOR_FRONTEND_BUCKET}/**/*.{js,css}
gcloud compute url-maps invalidate-cdn-cache ${DIKTATOR_PROJECT_ID}-frontend-url-map --path="/" --async
"""

# Additional development utilities
[tasks.check]
description = "Alias for test - run all quality checks"
run = "mise run test"

[tasks.fmt]
description = "Alias for format - format all code"
run = "mise run format"

# Google Cloud setup tasks
[tasks.gcloud-auth]
description = "Authenticate with Google Cloud"
run = """
echo "Starting Google Cloud authentication..."
gcloud auth login
gcloud auth application-default login
echo "Authentication completed!"
"""

[tasks.gcloud-set-project]
description = "Set Google Cloud project (pass project ID as argument)"
run = """
if [ -z "$1" ]; then
  echo "Usage: mise run gcloud-set-project -- YOUR_PROJECT_ID"
  echo "Current project: $(gcloud config get-value project 2>/dev/null || echo 'Not set')"
  exit 1
fi
echo "Setting Google Cloud project to: $1"
gcloud config set project "$1"
echo "Project set successfully!"
"""

[tasks.gcloud-enable-apis]
description = "Enable required Google Cloud APIs"
run = """
PROJECT_ID=$(gcloud config get-value project 2>/dev/null)
if [ -z "$PROJECT_ID" ]; then
  echo "Error: No Google Cloud project set. Run 'mise run gcloud-set-project -- YOUR_PROJECT_ID' first"
  exit 1
fi

echo "Enabling APIs for project: $PROJECT_ID"
gcloud services enable \
  run.googleapis.com \
  containerregistry.googleapis.com \
  storage.googleapis.com \
  iam.googleapis.com \
  cloudresourcemanager.googleapis.com
echo "APIs enabled successfully!"
"""

# Firebase setup
[tasks.firebase-setup]
description = "Set up Firebase emulators and configuration"
run = """
echo "Setting up Firebase for local development..."

# Check if Firebase CLI is installed
if ! command -v firebase &> /dev/null; then
    echo "Installing Firebase CLI..."
    npm install -g firebase-tools
fi

# Initialize Firebase in frontend directory if not already done
cd frontend

if [ ! -f firebase.json ]; then
    echo "Firebase configuration not found. Setting up Firebase emulators..."

    # Create basic firebase.json for emulators
    cat > firebase.json << 'EOF'
{
  "emulators": {
    "auth": {
      "port": 9099
    },
    "firestore": {
      "port": 8088
    },
    "ui": {
      "enabled": true,
      "port": 4000
    }
  }
}
EOF
    echo "✅ firebase.json created"
fi

if [ ! -f firestore.rules ]; then
    cat > firestore.rules << 'EOF'
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Allow users to read and write their own data
    match /users/{userId} {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

    // Allow users to read and write their own test results
    match /testResults/{resultId} {
      allow read, write: if request.auth != null && request.auth.uid == resource.data.userId;
      allow create: if request.auth != null && request.auth.uid == request.resource.data.userId;
    }
  }
}
EOF
    echo "✅ firestore.rules created"
fi

if [ ! -f firestore.indexes.json ]; then
    cat > firestore.indexes.json << 'EOF'
{
  "indexes": [
    {
      "collectionGroup": "testResults",
      "queryScope": "COLLECTION",
      "fields": [
        {
          "fieldPath": "userId",
          "order": "ASCENDING"
        },
        {
          "fieldPath": "completedAt",
          "order": "DESCENDING"
        }
      ]
    }
  ],
  "fieldOverrides": []
}
EOF
    echo "✅ firestore.indexes.json created"
fi

# Create environment file if it doesn't exist
if [ ! -f .env.local ]; then
    if [ -f .env.local.example ]; then
        cp .env.local.example .env.local
        echo "✅ .env.local created from example"
    else
        echo "Creating basic .env.local for Firebase emulators..."
        cat > .env.local << 'EOF'
# Firebase Emulator Configuration
NEXT_PUBLIC_FIREBASE_USE_EMULATOR=true
NEXT_PUBLIC_FIREBASE_API_KEY=demo-api-key
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=demo-diktator.firebaseapp.com
NEXT_PUBLIC_FIREBASE_PROJECT_ID=demo-diktator
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=demo-diktator.appspot.com
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=demo-sender-id
NEXT_PUBLIC_FIREBASE_APP_ID=demo-app-id
EOF
        echo "✅ .env.local created with emulator configuration"
    fi
fi

echo ""
echo "Firebase setup complete! You can now run 'mise run firebase-emulators' to start the emulators."
"""

[tasks.firebase-emulators]
description = "Start Firebase emulators"
run = """
cd frontend
echo "Starting Firebase emulators..."
echo "This will start:"
echo "  - Authentication emulator on port 9099"
echo "  - Firestore emulator on port 8088"
echo "  - Emulator UI on port 4000"
echo ""
echo "Press Ctrl+C to stop the emulators"
firebase emulators:start
"""

# Configuration management tasks
[tasks.config-load]
description = "Load dynamic configuration from terraform outputs"
run = """
echo "Loading dynamic configuration..."
cd terraform

# Check if terraform is initialized
if [ ! -d .terraform ]; then
    echo "Terraform not initialized. Run 'mise run tofu-init' first."
    exit 1
fi

# Check if tfstate exists
if [ ! -f terraform.tfstate ]; then
    echo "No terraform state found. Infrastructure may not be deployed yet."
    echo "Run 'mise run tofu-apply' to deploy infrastructure first."
    exit 1
fi

# Extract outputs and create .mise.env
echo "Extracting terraform outputs..."
cat > ../.mise.env << EOF
# Auto-generated from terraform outputs - do not edit manually
DIKTATOR_PROJECT_ID=$(tofu output -raw project_id 2>/dev/null || echo "")
DIKTATOR_REGION=$(tofu output -raw region 2>/dev/null || echo "${DIKTATOR_DEFAULT_REGION}")
DIKTATOR_FRONTEND_BUCKET=$(tofu output -raw frontend_bucket_name 2>/dev/null || echo "")
DIKTATOR_API_URL=$(tofu output -raw api_url 2>/dev/null || echo "")

# Firebase configuration from terraform outputs
DIKTATOR_FIREBASE_API_KEY=$(tofu output -json firebase_config 2>/dev/null | jq -r '.apiKey' 2>/dev/null || echo "")
DIKTATOR_FIREBASE_AUTH_DOMAIN=$(tofu output -json firebase_config 2>/dev/null | jq -r '.authDomain' 2>/dev/null || echo "")
DIKTATOR_FIREBASE_STORAGE_BUCKET=$(tofu output -json firebase_config 2>/dev/null | jq -r '.storageBucket' 2>/dev/null || echo "")
DIKTATOR_FIREBASE_MESSAGING_SENDER_ID=$(tofu output -json firebase_config 2>/dev/null | jq -r '.messagingSenderId' 2>/dev/null || echo "")
DIKTATOR_FIREBASE_APP_ID=$(tofu output -json firebase_config 2>/dev/null | jq -r '.appId' 2>/dev/null || echo "")
EOF

echo "Configuration loaded to .mise.env"
"""

[tasks.config-check]
description = "Check all configuration values"
run = """
echo "=== Static Configuration (mise.toml) ==="
echo "DIKTATOR_APP_NAME: ${DIKTATOR_APP_NAME}"
echo "DIKTATOR_API_SERVICE_NAME: ${DIKTATOR_API_SERVICE_NAME}"
echo "DIKTATOR_DEFAULT_REGION: ${DIKTATOR_DEFAULT_REGION}"
echo "DIKTATOR_DEFAULT_PORT: ${DIKTATOR_DEFAULT_PORT}"
echo "DIKTATOR_BUCKET_LOCATION: ${DIKTATOR_BUCKET_LOCATION}"
echo ""

if [ -f .mise.env ]; then
    echo "=== Dynamic Configuration (.mise.env) ==="
    source .mise.env
    echo "DIKTATOR_PROJECT_ID: ${DIKTATOR_PROJECT_ID:-'Not set'}"
    echo "DIKTATOR_REGION: ${DIKTATOR_REGION:-'Not set'}"
    echo "DIKTATOR_FRONTEND_BUCKET: ${DIKTATOR_FRONTEND_BUCKET:-'Not set'}"
    echo "DIKTATOR_API_URL: ${DIKTATOR_API_URL:-'Not set'}"
    echo ""
    echo "=== Firebase Configuration ==="
    echo "API Key: ${DIKTATOR_FIREBASE_API_KEY:-'Not set'}"
    echo "Auth Domain: ${DIKTATOR_FIREBASE_AUTH_DOMAIN:-'Not set'}"
    echo "Storage Bucket: ${DIKTATOR_FIREBASE_STORAGE_BUCKET:-'Not set'}"
    echo "Messaging Sender ID: ${DIKTATOR_FIREBASE_MESSAGING_SENDER_ID:-'Not set'}"
    echo "App ID: ${DIKTATOR_FIREBASE_APP_ID:-'Not set'}"
else
    echo "=== Dynamic Configuration ==="
    echo "No .mise.env file found. Run 'mise run config-load' to generate it."
fi

echo ""
echo "=== Environment Variables ==="
echo "NODE_ENV: ${NODE_ENV}"
echo "GOOGLE_CLOUD_PROJECT: ${GOOGLE_CLOUD_PROJECT}"
echo "NEXT_PUBLIC_API_URL: ${NEXT_PUBLIC_API_URL}"
echo "NEXT_PUBLIC_FIREBASE_USE_EMULATOR: ${NEXT_PUBLIC_FIREBASE_USE_EMULATOR}"
"""

[tasks.env-production]
description = "Generate production environment file for frontend"
run = """
# Load dynamic configuration first
if [ -f .mise.env ]; then
    source .mise.env
else
    echo "Warning: .mise.env not found. Run 'mise run config-load' first."
fi

cd frontend

echo "Generating production .env.local..."
cat > .env.local << EOF
# Production environment - auto-generated
NODE_ENV=production
NEXT_PUBLIC_API_URL=${DIKTATOR_API_URL:-"https://${DIKTATOR_API_SERVICE_NAME}-${DIKTATOR_REGION:-${DIKTATOR_DEFAULT_REGION}}.run.app"}

# Firebase Production Configuration
NEXT_PUBLIC_FIREBASE_USE_EMULATOR=false
NEXT_PUBLIC_FIREBASE_API_KEY=${DIKTATOR_FIREBASE_API_KEY:-""}
NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=${DIKTATOR_FIREBASE_AUTH_DOMAIN:-""}
NEXT_PUBLIC_FIREBASE_PROJECT_ID=${DIKTATOR_PROJECT_ID:-""}
NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=${DIKTATOR_FIREBASE_STORAGE_BUCKET:-""}
NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=${DIKTATOR_FIREBASE_MESSAGING_SENDER_ID:-""}
NEXT_PUBLIC_FIREBASE_APP_ID=${DIKTATOR_FIREBASE_APP_ID:-""}
EOF

echo "Production .env.local generated"
echo "API URL: ${DIKTATOR_API_URL:-"https://${DIKTATOR_API_SERVICE_NAME}-${DIKTATOR_REGION:-${DIKTATOR_DEFAULT_REGION}}.run.app"}"
echo ""
echo "Firebase Configuration:"
echo "  Project ID: ${DIKTATOR_PROJECT_ID:-'Not set'}"
echo "  Auth Domain: ${DIKTATOR_FIREBASE_AUTH_DOMAIN:-'Not set'}"
echo "  App ID: ${DIKTATOR_FIREBASE_APP_ID:-'Not set'}"
"""
