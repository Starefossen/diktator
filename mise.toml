[tools]
go = "1.25"
node = "24"
opentofu = "latest"
air = "latest"
pnpm = "10"

# ============================================================================
# Environment Configuration
# ============================================================================
[env]
# Static configuration - same across all environments
DIKTATOR_APP_NAME = "diktator"
DIKTATOR_API_SERVICE_NAME = "diktator-api"

# Development environment defaults
TTS_PROJECT = "diktator-dev"
TTS_QUOTA_PROJECT = "diktator-app"
GIN_MODE = "debug"

# PostgreSQL configuration
DATABASE_URL = "postgresql://postgres:postgres@localhost:5432/diktator?sslmode=disable"
DATABASE_TEST_URL = "postgresql://postgres:postgres@localhost:5432/diktator_test?sslmode=disable"

# Authentication - mock mode for development
AUTH_MODE = "mock"
MOCK_USER_ID = "mock-user-12345"
MOCK_USER_EMAIL = "dev@localhost"
MOCK_USER_NAME = "Development User"

# Frontend configuration
NEXT_PUBLIC_API_URL = "http://localhost:8080"
NEXT_PUBLIC_AUTH_MODE = "mock"
NEXT_TELEMETRY_DISABLED = "1"
NODE_ENV = "development"

# Port configuration
BACKEND_PORT = "8080"
FRONTEND_PORT = "3000"

# Docker Compose configuration
DOCKER_COMPOSE_FILE = "docker-compose.dev.yml"

# Wait times (in seconds)
DB_STARTUP_WAIT = "3"
BACKEND_STARTUP_WAIT = "3"
BACKEND_STOP_WAIT = "1"
DB_RESET_WAIT = "5"

# Timeouts (kubectl wait)
POD_READY_TIMEOUT = "600s"
KNATIVE_READY_TIMEOUT = "300s"

# Directory paths
TMP_DIR = ".tmp"
BACKEND_DIR = "backend"
FRONTEND_DIR = "frontend"
TERRAFORM_DIR = "terraform"
DEPLOY_DIR = "deploy"

# Build configuration
TARGETARCH = "amd64"
TTS_CACHE_SIZE_MB = "15"

# Homelab deployment configuration
REGISTRY_URL = "registry.intern.flaatten.org:5000"
NAMESPACE = "diktator"
BACKEND_SERVICE = "api"
FRONTEND_SERVICE = "www"

# Homelab OIDC configuration
HOMELAB_API_URL = "https://api.diktator.fn.flaatten.org"
HOMELAB_APP_URL = "https://www.diktator.fn.flaatten.org"
HOMELAB_OIDC_ISSUER_URL = "https://zitadel.zitadel.fn.flaatten.org"
HOMELAB_OIDC_CLIENT_ID = "353809168672555052"

# ============================================================================
# Private Helper Tasks
# ============================================================================
# These tasks are prefixed with _ to mark them as internal utilities.
# They are not intended to be run directly by users.

[tasks._validate-env]
# Validates that required environment variables are set
description = "[Internal] Validate required environment variables"
run = """
REQUIRED_VARS="TTS_PROJECT TTS_QUOTA_PROJECT DATABASE_URL DATABASE_TEST_URL"
MISSING_VARS=""

for VAR in $REQUIRED_VARS; do
    if [ -z "${!VAR}" ]; then
        MISSING_VARS="$MISSING_VARS $VAR"
    fi
done

if [ -n "$MISSING_VARS" ]; then
    echo "âŒ Missing required environment variables:$MISSING_VARS"
    exit 1
fi
"""

[tasks._docker-compose]
# Wrapper for docker compose commands using the configured file
description = "[Internal] Run docker compose with configured file"
run = "docker compose -f ${DOCKER_COMPOSE_FILE} $@"

[tasks._ensure-postgres]
# Ensures PostgreSQL is running, starts it if not
description = "[Internal] Ensure PostgreSQL is running"
run = """
if ! docker compose -f ${DOCKER_COMPOSE_FILE} ps postgres 2>/dev/null | grep -q "running"; then
    echo "ğŸ˜ Starting PostgreSQL..."
    docker compose -f ${DOCKER_COMPOSE_FILE} up -d postgres
    sleep ${DB_STARTUP_WAIT}
fi
"""

[tasks._wait-postgres]
# Waits for PostgreSQL to be ready to accept connections
description = "[Internal] Wait for PostgreSQL to be ready"
depends = ["_ensure-postgres"]
run = """
echo "â³ Waiting for PostgreSQL to be ready..."
sleep ${DB_STARTUP_WAIT}
"""

[tasks._ensure-config]
# Ensures development configuration files exist
description = "[Internal] Ensure development config files exist"
run = """
if [ ! -f ${BACKEND_DIR}/.env.development ]; then
    echo "ğŸ“ Generating development config..."
    mise run config:dev
fi
"""

[tasks._load-dev-env]
# Loads development environment variables into current shell context
description = "[Internal] Load development environment variables"
depends = ["_ensure-config"]
dir = "backend"
run = "set -a && source .env.development && set +a"

[tasks._wait-backend]
# Waits for backend to be ready to accept connections
description = "[Internal] Wait for backend to be ready"
run = """
echo "â³ Waiting for backend to be ready..."
sleep ${BACKEND_STARTUP_WAIT}
"""

# ============================================================================
# Development Tasks
# ============================================================================

[tasks.install]
description = "Install all dependencies"
run = """
echo "ğŸ“¦ Installing dependencies..."
(cd ${FRONTEND_DIR} && pnpm install) &
(cd ${BACKEND_DIR} && go mod tidy) &
wait
go install github.com/swaggo/swag/cmd/swag@latest
echo "âœ… All dependencies installed"
"""

[tasks.dev]
description = "Start full development environment (PostgreSQL + frontend + backend)"
depends = ["_ensure-config", "_ensure-postgres"]
run = """
echo "ğŸš€ Starting full development environment..."

# Ensure dependencies are installed
if [ ! -d ${FRONTEND_DIR}/node_modules ] || [ ! -f ${BACKEND_DIR}/go.sum ]; then
    echo "ğŸ“¦ Installing dependencies..."
    mise run install
fi

# Start backend with air (hot reload) in background
echo "ğŸ”§ Starting backend with hot reload..."
cd ${BACKEND_DIR} && set -a && source .env.development && set +a && air &
BACKEND_PID=$!
sleep ${BACKEND_STARTUP_WAIT}

# Check if backend started successfully
if ! kill -0 $BACKEND_PID 2>/dev/null; then
    echo "âŒ Backend failed to start"
    exit 1
fi

echo "âœ… Backend started (PID: $BACKEND_PID)"

# Start frontend
echo "âš›ï¸  Starting frontend..."
cd ${FRONTEND_DIR} && cp .env.development .env.local && pnpm run dev

# Cleanup on exit
cleanup() {
    echo ""
    echo "ğŸ›‘ Stopping services..."
    kill $BACKEND_PID 2>/dev/null || true
    docker compose -f ${DOCKER_COMPOSE_FILE} down
}
trap cleanup EXIT INT TERM
"""

[tasks."frontend:dev"]
description = "Start frontend development server"
depends = ["_ensure-config"]
dir = "frontend"
run = """
cp .env.development .env.local
pnpm run dev
"""

[tasks."backend:dev"]
description = "Start backend with hot reload (air)"
depends = ["_ensure-config"]
dir = "backend"
run = """
set -a && source .env.development && set +a && air
"""

# ============================================================================
# Backend Service Management
# ============================================================================

[tasks."backend:start"]
description = "Start backend in background"
depends = ["_ensure-config", "_ensure-postgres"]
run = """
mkdir -p ${TMP_DIR}

if [ -f ${TMP_DIR}/backend.pid ] && kill -0 $(cat ${TMP_DIR}/backend.pid) 2>/dev/null; then
    echo "âš ï¸  Backend already running (PID: $(cat ${TMP_DIR}/backend.pid))"
    exit 0
fi

echo "ğŸš€ Starting backend..."
cd ${BACKEND_DIR}
set -a && source .env.development && set +a
nohup go run cmd/server/main.go > ../${TMP_DIR}/backend.log 2>&1 &
echo $! > ../${TMP_DIR}/backend.pid
cd ..

sleep ${BACKEND_STARTUP_WAIT}
if kill -0 $(cat ${TMP_DIR}/backend.pid) 2>/dev/null; then
    echo "âœ… Backend started (PID: $(cat ${TMP_DIR}/backend.pid))"
    echo "   Logs: ${TMP_DIR}/backend.log"
    curl -s http://localhost:${BACKEND_PORT}/health | head -c 100
    echo ""
else
    echo "âŒ Backend failed to start"
    tail -20 ${TMP_DIR}/backend.log
    exit 1
fi
"""

[tasks."backend:stop"]
description = "Stop backend"
run = """
if [ -f ${TMP_DIR}/backend.pid ]; then
    PID=$(cat ${TMP_DIR}/backend.pid)
    if kill -0 $PID 2>/dev/null; then
        echo "Stopping backend (PID: $PID)..."
        kill $PID
        sleep ${BACKEND_STOP_WAIT}
        kill -0 $PID 2>/dev/null && kill -9 $PID
        echo "âœ… Backend stopped"
    fi
    rm -f ${TMP_DIR}/backend.pid
else
    lsof -ti:${BACKEND_PORT} | xargs kill -9 2>/dev/null || true
fi
"""

[tasks."backend:logs"]
description = "View backend logs"
run = """
if [ -f ${TMP_DIR}/backend.log ]; then
    tail -f ${TMP_DIR}/backend.log
else
    echo "No log file found. Start backend with 'mise run backend:start'"
fi
"""

[tasks."backend:status"]
description = "Check backend status"
run = """
if [ -f ${TMP_DIR}/backend.pid ] && kill -0 $(cat ${TMP_DIR}/backend.pid) 2>/dev/null; then
    echo "âœ… Backend running (PID: $(cat ${TMP_DIR}/backend.pid))"
    curl -s http://localhost:${BACKEND_PORT}/health 2>/dev/null || echo "âŒ Not responding"
else
    echo "âŒ Backend not running"
fi
"""

[tasks."backend:restart"]
description = "Restart backend"
run = "mise run backend:stop && sleep ${BACKEND_STOP_WAIT} && mise run backend:start"

# ============================================================================
# Database Tasks
# ============================================================================

[tasks."db:start"]
description = "Start PostgreSQL"
run = """
docker compose -f ${DOCKER_COMPOSE_FILE} up -d
echo "PostgreSQL started at localhost:5432"
"""

[tasks."db:stop"]
description = "Stop PostgreSQL"
run = "docker compose -f ${DOCKER_COMPOSE_FILE} down"

[tasks."db:reset"]
description = "Reset database (destroy and recreate)"
run = """
echo "WARNING: This will delete all data!"
read -p "Are you sure? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    docker compose -f ${DOCKER_COMPOSE_FILE} down -v
    docker compose -f ${DOCKER_COMPOSE_FILE} up -d
    echo "âœ… Database reset complete. Migrations will run on next backend start."
fi
"""

# Migrations now run automatically on backend startup (see backend/internal/migrate)

[tasks."db:reset-test"]
description = "Reset test database (destroy and recreate)"
run = """
echo "Resetting test database..."
docker compose -f ${DOCKER_COMPOSE_FILE} exec -T postgres psql -U postgres -c "DROP DATABASE IF EXISTS diktator_test;"
docker compose -f ${DOCKER_COMPOSE_FILE} exec -T postgres psql -U postgres -c "CREATE DATABASE diktator_test;"
echo "âœ… Test database reset complete. Migrations will run on next test."
"""

[tasks."db:shell"]
description = "Open PostgreSQL shell"
run = "docker compose -f ${DOCKER_COMPOSE_FILE} exec postgres psql -U postgres -d diktator"

[tasks."db:seed"]
description = "Seed database with test data"
dir = "backend"
run = """
echo "ğŸŒ± Seeding database with test data..."
go run cmd/seed/main.go
"""

[tasks."db:reset-seed"]
description = "Reset database and seed with fresh test data"
run = """
echo "ğŸ”„ Resetting database..."
mise run db:reset

echo "â³ Waiting for database..."
sleep ${DB_RESET_WAIT}

echo "ğŸŒ± Seeding test data..."
mise run db:seed

echo "âœ… Database reset and seeded!"
"""

# ============================================================================
# Code Quality
# ============================================================================

[tasks.lint]
description = "Run linters"
run = """
(cd ${FRONTEND_DIR} && pnpm run lint) &
(cd ${BACKEND_DIR} && go vet ./...) &
wait
"""

[tasks.format]
description = "Format code"
run = """
(cd ${FRONTEND_DIR} && pnpm run format) &
(cd ${BACKEND_DIR} && go fmt ./...) &
(cd ${TERRAFORM_DIR} && tofu fmt) &
wait
"""

[tasks.typecheck]
description = "Type check all code"
run = """
(cd ${FRONTEND_DIR} && pnpm run typecheck) &
(cd ${BACKEND_DIR} && go build -o /dev/null ./...) &
wait
"""

[tasks."frontend:knip"]
description = "Find unused code in frontend"
dir = "frontend"
run = "pnpm run knip"

[tasks."frontend:knip-fix"]
description = "Auto-fix unused code in frontend"
dir = "frontend"
run = "pnpm run knip:fix"

[tasks."frontend:check"]
description = "Run all frontend checks (typecheck, lint:fix, format, knip:fix, test) with auto-fixing"
dir = "frontend"
run = "pnpm run check"

[tasks."frontend:build"]
description = "Build frontend for production"
dir = "frontend"
run = """
cp .env.production .env.local 2>/dev/null || true
NODE_ENV=production pnpm run build
"""

[tasks."backend:check"]
description = "Run all backend checks (fmt, vet, test) with auto-fixing"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "ğŸ”§ Running backend checks..."
echo ""
echo "ğŸ“ Formatting code..."
go fmt ./...

echo ""
echo "ğŸ” Running go vet..."
go vet ./...

echo ""
echo "ğŸ§ª Running tests..."
DATABASE_URL="${DATABASE_TEST_URL}" go test ./...

echo ""
echo "âœ… All backend checks passed!"
"""

[tasks.test]
description = "Run all tests (lint + typecheck + backend + frontend unit tests)"
depends = ["_ensure-postgres"]
run = """
echo "ğŸ§ª Running all tests..."

echo ""
echo "ğŸ“‹ Running linters..."
mise run lint &
LINT_PID=$!

echo ""
echo "ğŸ” Type checking..."
mise run typecheck &
TYPE_PID=$!

wait $LINT_PID $TYPE_PID

echo ""
echo "ğŸ”§ Backend tests..."
(cd ${BACKEND_DIR} && DATABASE_URL="${DATABASE_TEST_URL}" go test ./...) &
BACKEND_PID=$!

echo ""
echo "âš›ï¸  Frontend unit tests..."
(cd ${FRONTEND_DIR} && pnpm test) &
FRONTEND_PID=$!

wait $BACKEND_PID $FRONTEND_PID

echo ""
echo "âœ… All tests passed!"
"""

[tasks."test:unit"]
description = "Run unit tests only (backend + frontend, skip integration)"
run = """
echo "ğŸ§ª Running unit tests..."

echo ""
echo "ğŸ”§ Backend unit tests..."
(cd ${BACKEND_DIR} && go test -short ./...) &

echo ""
echo "âš›ï¸  Frontend unit tests..."
(cd ${FRONTEND_DIR} && pnpm test) &

wait

echo "âœ… Unit tests passed!"
"""

[tasks."test:integration"]
description = "Run integration tests only (backend with real PostgreSQL)"
depends = ["_ensure-postgres", "db:reset-test"]
run = """
echo "ğŸ§ª Running integration tests with real database..."
(cd ${BACKEND_DIR} && TEST_DATABASE_URL="${DATABASE_TEST_URL}" INTEGRATION_TESTS=true go test -v -run Integration ./handlers)
"""

[tasks."test:e2e"]
description = "Run end-to-end tests (Playwright - starts servers automatically)"
depends = ["_ensure-postgres"]
run = """
echo "ğŸ­ Running E2E tests..."
echo "Note: Playwright will start the frontend server automatically"
echo "      Backend will be started in background"
echo ""

# Create mock user in database if not exists (family and user must exist for tests)
(cd ${BACKEND_DIR} && set -a && source .env.development && set +a && \
psql "${DATABASE_URL}" <<'SQL'
-- Insert user first without family_id
INSERT INTO users (id, auth_id, email, display_name, family_id, role, is_active, created_at, last_active_at)
VALUES ('mock-user-12345', 'mock-user-12345', 'dev@localhost', 'Development User', NULL, 'parent', true, NOW(), NOW())
ON CONFLICT (id) DO NOTHING;

-- Insert family with the user as creator
INSERT INTO families (id, name, created_by, created_at, updated_at)
VALUES ('family-mock-user-12345', 'Development Family', 'mock-user-12345', NOW(), NOW())
ON CONFLICT (id) DO NOTHING;

-- Update user with family_id
UPDATE users SET family_id = 'family-mock-user-12345' WHERE id = 'mock-user-12345' AND family_id IS NULL;

-- Insert family member relationship
INSERT INTO family_members (family_id, user_id, joined_at)
VALUES ('family-mock-user-12345', 'mock-user-12345', NOW())
ON CONFLICT (family_id, user_id) DO NOTHING;
SQL
) > /dev/null 2>&1 && echo "âœ… Mock user ready" || echo "âš ï¸  Database setup had issues"

# Start backend in background for the test
(cd ${BACKEND_DIR} && set -a && source .env.development && set +a && go run cmd/server/main.go) > /tmp/e2e-backend.log 2>&1 &
BACKEND_PID=$!
echo "â³ Waiting for backend to start..."
sleep 5

# Check if backend started
if ! curl -s http://localhost:${BACKEND_PORT}/health > /dev/null 2>&1; then
    echo "âŒ Backend failed to start"
    kill $BACKEND_PID 2>/dev/null || true
    exit 1
fi

echo "âœ… Backend ready"

# Run tests (Playwright will start frontend via webServer config)
(cd ${FRONTEND_DIR} && HEADLESS=1 pnpm exec playwright test)

# Cleanup
TEST_EXIT=$?
kill $BACKEND_PID 2>/dev/null || true
exit $TEST_EXIT
"""

[tasks."backend:test"]
description = "Run backend tests"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "ğŸ”§ Running backend tests..."
DATABASE_URL="${DATABASE_TEST_URL}" go test -v ./...
"""

[tasks."backend:test-short"]
description = "Run backend tests without integration tests"
dir = "backend"
run = "go test -short -v ./..."

[tasks."backend:test-integration"]
description = "Run backend integration tests only (requires PostgreSQL)"
depends = ["_ensure-postgres", "db:reset-test"]
dir = "backend"
run = """
echo "ğŸ§ª Running integration tests with real database..."
TEST_DATABASE_URL="${DATABASE_TEST_URL}" INTEGRATION_TESTS=true go test -v -run Integration ./handlers
"""

[tasks."backend:test-coverage"]
description = "Run backend tests with coverage"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "ğŸ”§ Running backend tests with coverage..."
DATABASE_URL="${DATABASE_TEST_URL}" go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
echo "âœ… Coverage report: backend/coverage.html"
"""

[tasks."frontend:test"]
description = "Run frontend unit tests"
dir = "frontend"
run = "pnpm test"

[tasks."frontend:test-watch"]
description = "Run frontend tests in watch mode"
dir = "frontend"
run = "pnpm test:watch"

[tasks."frontend:test-coverage"]
description = "Run frontend tests with coverage"
dir = "frontend"
run = "pnpm test:coverage"

[tasks."frontend:test-e2e"]
description = "Run frontend E2E tests with Playwright"
dir = "frontend"
run = """
echo "ğŸ­ Running E2E tests..."

# Check if backend is running
if ! curl -s http://localhost:${BACKEND_PORT}/health > /dev/null 2>&1; then
    echo "âš ï¸  Backend not running. Starting backend..."
    mise run backend:start
    sleep ${BACKEND_STARTUP_WAIT}
fi

pnpm test:e2e
"""

[tasks."frontend:test-e2e-ui"]
description = "Run E2E tests with Playwright UI"
dir = "frontend"
run = """
# Check if backend is running
if ! curl -s http://localhost:${BACKEND_PORT}/health > /dev/null 2>&1; then
    echo "âš ï¸  Backend not running. Starting backend..."
    mise run backend:start
    sleep ${BACKEND_STARTUP_WAIT}
fi

pnpm test:e2e:ui
"""

[tasks."test:all"]
description = "Run complete test suite (unit + integration + E2E)"
depends = ["_ensure-postgres", "db:reset-test"]
run = """
echo "ğŸ§ª Running complete test suite..."

echo ""
echo "=== Unit Tests ==="
mise run test:unit

echo ""
echo "=== Integration Tests ==="
mise run test:integration

echo ""
echo "=== E2E Tests ==="
mise run test:e2e

echo ""
echo "âœ… All tests (unit + integration + E2E) passed!"
"""

[tasks.check]
description = "Run all checks (backend + frontend: fmt, lint, typecheck, knip, tests)"
run = """
echo "ğŸ” Running all checks..."
echo ""
echo "=== Backend Checks ==="
mise run backend:check

echo ""
echo "=== Frontend Checks ==="
mise run frontend:check

echo ""
echo "âœ… All checks passed!"
"""

[tasks.fmt]
description = "Format code (alias for format)"
run = "mise run format"

# ============================================================================
# API Documentation
# ============================================================================

[tasks."backend:swagger-gen"]
description = "Generate OpenAPI spec"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum"]
outputs = ["docs/swagger.json", "docs/swagger.yaml", "docs/docs.go"]
run = """
command -v swag &>/dev/null || go install github.com/swaggo/swag/cmd/swag@latest
swag init -g cmd/server/main.go --output docs --parseInternal
echo "âœ… OpenAPI spec generated"
"""

[tasks."frontend:client-gen"]
description = "Generate TypeScript client"
dir = "frontend"
sources = ["../backend/docs/swagger.json"]
outputs = ["src/generated/**/*.ts"]
run = """
npx @openapitools/openapi-generator-cli generate \
    -i ../backend/docs/swagger.json \
    -g typescript-axios \
    -o src/generated \
    --additional-properties=supportsES6=true,withInterfaces=true
echo "âœ… TypeScript client generated"
"""

# ============================================================================
# Build Tasks
# ============================================================================

[tasks.build]
description = "Build for production"
run = """
mise run backend:swagger-gen
mise run config:prod
(cd ${FRONTEND_DIR} && cp .env.production .env.local && pnpm run build) &
(cd ${BACKEND_DIR} && go build -o bin/server cmd/server/main.go) &
wait
"""

[tasks."backend:build-binary"]
description = "Build backend binary for target architecture"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum"]
outputs = ["bin/server-linux-*"]
run = """
ARCH=${TARGETARCH}
echo "ğŸ”¨ Building backend binary for linux-${ARCH}..."
mkdir -p bin
CGO_ENABLED=0 GOOS=linux GOARCH=${ARCH} go build -ldflags="-w -s" -o bin/server-linux-${ARCH} ./cmd/server/main.go
echo "âœ… Binary built: backend/bin/server-linux-${ARCH}"
"""

[tasks."backend:docker-build"]
description = "Build backend Docker image (builds binary first)"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum", "Dockerfile"]
run = """
ARCH=${TARGETARCH}
echo "ğŸ“¦ Building backend Docker image for ${ARCH}..."

# Build binary outside Docker for performance
mise run backend:build-binary

# Build minimal Docker image with pre-built binary
docker build --build-arg TARGETARCH=${ARCH} -t diktator-api:latest -t diktator-api:${ARCH} .
echo "âœ… Built: diktator-api:latest (linux-${ARCH})"
"""

[tasks."frontend:docker-build"]
description = "Build frontend Docker image with nginx"
depends = ["frontend:config-homelab"]
dir = "frontend"
sources = [
  "src/**/*.{ts,tsx,js,jsx,json,css}",
  "package.json",
  "pnpm-lock.yaml",
  "Dockerfile",
  "nginx.conf",
]
run = """
echo "ğŸ“¦ Building frontend Docker image..."

# Build frontend first
cp .env.production .env.local 2>/dev/null || true
NODE_ENV=production pnpm run build

# Build minimal Docker image with nginx
docker build -t diktator-frontend:latest .
echo "âœ… Built: diktator-frontend:latest"
"""

[tasks.clean]
description = "Clean build artifacts"
run = """
mise run backend:stop 2>/dev/null || true
rm -rf ${FRONTEND_DIR}/.next ${FRONTEND_DIR}/out ${FRONTEND_DIR}/src/generated ${FRONTEND_DIR}/dist
rm -rf ${BACKEND_DIR}/bin
rm -f ${FRONTEND_DIR}/.env.local ${BACKEND_DIR}/.env.* ${FRONTEND_DIR}/.env.*
rm -f .mise.env
rm -rf ${TMP_DIR}
echo "âœ… Build artifacts cleaned"
"""

# ============================================================================
# Setup & Configuration
# ============================================================================

[tasks.setup]
description = "Initial project setup"
run = """
echo "ğŸš€ Setting up Diktator..."

echo ""
echo "ğŸ“¦ Installing tools..."
mise install

echo ""
echo "ğŸ“ Generating development config..."
mise run config:dev

echo ""
echo "ğŸ“¦ Installing dependencies..."
mise run install

echo ""
echo "ğŸ˜ Starting PostgreSQL..."
docker compose -f ${DOCKER_COMPOSE_FILE} pull
docker compose -f ${DOCKER_COMPOSE_FILE} up -d
sleep ${DB_STARTUP_WAIT}

echo ""
echo "âœ… Setup complete!"
echo ""
echo "Next steps:"
echo "  Start full dev:     mise run dev"
echo "  Start backend only: mise run backend:start"
echo "  Start frontend:     mise run frontend:dev"
echo "  Run tests:          mise run test"
"""

[tasks."config:dev"]
description = "Generate development configuration"
depends = ["_validate-env"]
run = """
echo "ğŸ“ Generating development configuration..."
envsubst < ${BACKEND_DIR}/.env.development.tmpl > ${BACKEND_DIR}/.env.development
envsubst < ${FRONTEND_DIR}/.env.development.tmpl > ${FRONTEND_DIR}/.env.development
echo "âœ… Development config created"
"""

[tasks."config:prod"]
description = "Generate production configuration"
depends = ["_validate-env"]
run = """
if [ ! -f .mise.env ]; then
    echo "ERROR: .mise.env not found. Run 'mise run config:load' first."
    exit 1
fi
source .mise.env

echo "ğŸ“ Generating production configuration..."

# Note: Production config uses different variables than development
# Some vars like OIDC URLs need to be set in .mise.env before running this
cat > ${BACKEND_DIR}/.env.production << EOF
TTS_PROJECT=${DIKTATOR_PROJECT_ID}
TTS_QUOTA_PROJECT=${TTS_QUOTA_PROJECT:-${DIKTATOR_PROJECT_ID}}
GIN_MODE=release
PORT=8080
DATABASE_URL=${DATABASE_URL}
AUTH_MODE=oidc
OIDC_ISSUER_URL=${OIDC_ISSUER_URL:-https://auth.diktator.app}
OIDC_AUDIENCE=${OIDC_AUDIENCE:-diktator}
EOF

cat > ${FRONTEND_DIR}/.env.production << EOF
NEXT_PUBLIC_API_URL=${DIKTATOR_API_URL:-https://${DIKTATOR_API_SERVICE_NAME}-${DIKTATOR_REGION:-${DIKTATOR_DEFAULT_REGION}}.run.app}
NEXT_PUBLIC_AUTH_MODE=oidc
NEXT_PUBLIC_OIDC_ISSUER_URL=${OIDC_ISSUER_URL:-https://auth.diktator.app}
NEXT_PUBLIC_OIDC_CLIENT_ID=${OIDC_CLIENT_ID:-diktator-frontend}
NEXT_TELEMETRY_DISABLED=1
NODE_ENV=production
EOF

echo "âœ… Production config created"
"""

[tasks."config:load"]
description = "Load configuration from terraform"
dir = "terraform"
run = """
if [ ! -d .terraform ]; then
    echo "Terraform not initialized. Run 'mise run tofu:init'"
    exit 1
fi

cat > ../.mise.env << EOF
DIKTATOR_PROJECT_ID=$(tofu output -raw project_id 2>/dev/null || echo "")
EOF
echo "Configuration loaded to .mise.env"
"""

# ============================================================================
# Infrastructure (OpenTofu)
# ============================================================================

[tasks."tofu:init"]
description = "Initialize OpenTofu"
dir = "terraform"
run = "tofu init"

[tasks."tofu:plan"]
description = "Plan infrastructure changes"
dir = "terraform"
run = "tofu plan"

[tasks."tofu:apply"]
description = "Apply infrastructure"
dir = "terraform"
run = "tofu apply"

[tasks."tofu:destroy"]
description = "Destroy infrastructure"
dir = "terraform"
run = "tofu destroy"

[tasks."tofu:fmt"]
description = "Format terraform files"
dir = "terraform"
run = "tofu fmt"

# ============================================================================
# Homelab Deployment (Knative)
# ============================================================================

[tasks."homelab:backend:build"]
description = "Build backend binaries and Docker image for homelab"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum", "Dockerfile"]
outputs = [
  "bin/server-linux-amd64",
  "bin/server-linux-arm64",
  "../.build-tag-backend",
]
run = """
echo "ğŸ”¨ Building backend binaries..."

# Build for linux/amd64
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/server-linux-amd64 ./cmd/server

# Build for linux/arm64
CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o bin/server-linux-arm64 ./cmd/server

echo "ğŸ“¦ Building and pushing Docker image..."
BUILD_TAG=$(date +%s)

# Build multi-arch image
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  --build-arg TARGETARCH=amd64 \
  -t ${REGISTRY_URL}/${BACKEND_SERVICE}:${BUILD_TAG} \
  --push \
  .

# Save build tag for deployment
echo ${BUILD_TAG} > ../.build-tag-backend
echo "âœ… Backend built: ${REGISTRY_URL}/${BACKEND_SERVICE}:${BUILD_TAG}"
"""

[tasks."frontend:config-homelab"]
description = "Generate frontend build configuration for homelab Knative deployment"
run = """
cat > ${FRONTEND_DIR}/.env.production << EOF
NEXT_PUBLIC_API_URL=${HOMELAB_API_URL}
NEXT_PUBLIC_APP_URL=${HOMELAB_APP_URL}
NEXT_PUBLIC_AUTH_MODE=oidc
NEXT_PUBLIC_OIDC_ISSUER_URL=${HOMELAB_OIDC_ISSUER_URL}
NEXT_PUBLIC_OIDC_CLIENT_ID=${HOMELAB_OIDC_CLIENT_ID}
NEXT_PUBLIC_OIDC_REDIRECT_URI=${HOMELAB_APP_URL}/auth/callback
NEXT_PUBLIC_OIDC_POST_LOGOUT_REDIRECT_URI=${HOMELAB_APP_URL}
NEXT_TELEMETRY_DISABLED=1
NODE_ENV=production
EOF
echo "âœ… Homelab config: ${FRONTEND_DIR}/.env.production"
"""

[tasks."homelab:frontend:build"]
description = "Build frontend and Docker image for homelab"
depends = ["frontend:config-homelab"]
dir = "frontend"
sources = [
  "src/**/*.{ts,tsx,js,jsx,json,css}",
  "package.json",
  "pnpm-lock.yaml",
  "Dockerfile",
  "nginx.conf",
]
outputs = ["out/**/*", "../.build-tag-frontend"]
run = """
echo "ğŸ”¨ Building frontend static files..."
pnpm install
source .env.production
NODE_ENV=production pnpm run build

echo "ğŸ“¦ Building and pushing Docker image..."
BUILD_TAG=$(date +%s)

# Build multi-arch image
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  -t ${REGISTRY_URL}/${FRONTEND_SERVICE}:${BUILD_TAG} \
  --push \
  .

# Save build tag for deployment
echo ${BUILD_TAG} > ../.build-tag-frontend
echo "âœ… Frontend built: ${REGISTRY_URL}/${FRONTEND_SERVICE}:${BUILD_TAG}"
"""

[tasks."homelab:build"]
description = "Build both backend and frontend for homelab"
depends = ["homelab:backend:build", "homelab:frontend:build"]

[tasks."homelab:gcp:export-credentials"]
description = "Export TTS credentials from Terraform"
dir = "terraform"
run = """
echo "ğŸ“¥ Exporting TTS service credentials..."

if [ ! -d ".terraform" ]; then
  echo "âŒ Terraform not initialized. Run 'mise run tofu:init' first."
  exit 1
fi

if ! tofu output app_service_account_key >/dev/null 2>&1; then
  echo "âŒ No service account found. Run 'mise run tofu:apply' first."
  exit 1
fi

tofu output -raw app_service_account_key | base64 -d > ../${DEPLOY_DIR}/gcp-credentials.json
echo "âœ… Credentials exported to ${DEPLOY_DIR}/gcp-credentials.json"
"""

[tasks."homelab:gcp:create-secret"]
description = "Create Kubernetes secret for TTS credentials"
depends = ["homelab:namespace:create", "homelab:gcp:export-credentials"]
run = """
if [ ! -f "${DEPLOY_DIR}/gcp-credentials.json" ]; then
  echo "âŒ Credentials file not found. Run 'mise run homelab:gcp:export-credentials' first."
  exit 1
fi

echo "ğŸ” Creating Kubernetes secret..."

# Delete existing secret if it exists
kubectl delete secret gcp-credentials -n ${NAMESPACE} 2>/dev/null || true

# Create new secret
kubectl create secret generic gcp-credentials \
  --from-file=key.json=${DEPLOY_DIR}/gcp-credentials.json \
  -n ${NAMESPACE}

# Delete credentials file from disk
rm -f ${DEPLOY_DIR}/gcp-credentials.json

echo "âœ… Secret 'gcp-credentials' created in namespace ${NAMESPACE}"
echo "ğŸ—‘ï¸  Credentials file removed from disk"
"""

[tasks."homelab:namespace:create"]
description = "Create namespace if it doesn't exist"
run = """
if ! kubectl get namespace ${NAMESPACE} >/dev/null 2>&1; then
  kubectl create namespace ${NAMESPACE}
  echo "âœ… Created namespace: ${NAMESPACE}"
else
  echo "âœ“ Namespace ${NAMESPACE} already exists"
fi
"""

[tasks."homelab:network:apply"]
description = "Apply Cilium network policies"
depends = ["homelab:namespace:create"]
run = """
echo "ğŸ”’ Applying network policies..."
kubectl apply -f ${DEPLOY_DIR}/networkpolicy.yaml
echo "âœ… Network policies applied"
"""

[tasks."homelab:backend:deploy"]
description = "Deploy backend to Knative"
depends = ["homelab:gcp:create-secret"]
run = """
if [ ! -f ".build-tag-backend" ]; then
  echo "âŒ No build tag found. Run 'mise run homelab:backend:build' first."
  exit 1
fi

BUILD_TAG=$(cat .build-tag-backend)

echo "ğŸš€ Deploying backend: ${BACKEND_SERVICE}:${BUILD_TAG}"

# Update image tag in manifest
sed "s|BUILD_TAG|${BUILD_TAG}|" \
  ${DEPLOY_DIR}/knative-service-backend.yaml | kubectl apply -f -

echo "â³ Waiting for backend to be ready..."
kubectl wait --for=condition=Ready \
  --timeout=${KNATIVE_READY_TIMEOUT} \
  -n ${NAMESPACE} \
  ksvc/${BACKEND_SERVICE}

echo "âœ… Backend deployed successfully"
"""

[tasks."homelab:frontend:deploy"]
description = "Deploy frontend to Knative"
run = """
if [ ! -f ".build-tag-frontend" ]; then
  echo "âŒ No build tag found. Run 'mise run homelab:frontend:build' first."
  exit 1
fi

BUILD_TAG=$(cat .build-tag-frontend)

echo "ğŸš€ Deploying frontend: ${FRONTEND_SERVICE}:${BUILD_TAG}"

# Update image tag in manifest
sed "s|BUILD_TAG|${BUILD_TAG}|" \
  ${DEPLOY_DIR}/knative-service-frontend.yaml | kubectl apply -f -

echo "â³ Waiting for frontend to be ready..."
kubectl wait --for=condition=Ready \
  --timeout=${KNATIVE_READY_TIMEOUT} \
  -n ${NAMESPACE} \
  ksvc/${FRONTEND_SERVICE}

echo "âœ… Frontend deployed successfully"
"""

[tasks."homelab:deploy"]
description = "Deploy both backend and frontend to homelab"
depends = [
  "homelab:namespace:create",
  "homelab:gcp:create-secret",
  "homelab:network:apply",
  "homelab:backend:deploy",
  "homelab:frontend:deploy",
]

[tasks."homelab:deploy:full"]
description = "Build and deploy both services to homelab"
depends = ["homelab:build", "homelab:deploy"]

[tasks."homelab:db:create"]
description = "Create PostgreSQL database"
depends = ["homelab:namespace:create"]
run = """
echo "ğŸ“Š Creating database..."
kubectl apply -f ${DEPLOY_DIR}/postgres-cluster.yaml

echo "â³ Waiting for database pod to be ready (this may take 2-5 minutes)..."

# Wait for pods to be ready (more reliable than cluster condition)
if kubectl wait --for=condition=Ready \
  --timeout=${POD_READY_TIMEOUT} \
  -n ${NAMESPACE} \
  pod -l cnpg.io/cluster=diktator-db 2>/dev/null; then
  echo "âœ… Database pod is ready"
else
    echo "âš ï¸  Pod readiness check failed. Verifying cluster status..."

    # Check if cluster resource exists and its conditions
    echo "ğŸ“‹ Cluster status:"
    kubectl get cluster diktator-db -n ${NAMESPACE} -o wide
    echo ""
    echo "ğŸ“‹ Cluster conditions:"
    kubectl get cluster diktator-db -n ${NAMESPACE} -o jsonpath='{.status.conditions[*]}' | jq . 2>/dev/null || true
    echo ""

    # Check pod status directly
    echo "ğŸ“‹ PostgreSQL pod status:"
    kubectl get pods -n ${NAMESPACE} -l cnpg.io/cluster=diktator-db
    echo ""

    # If pod exists and is running, consider it success despite timeout
    if kubectl get pods -n ${NAMESPACE} -l cnpg.io/cluster=diktator-db -o jsonpath='{.items[0].status.phase}' 2>/dev/null | grep -q Running; then
      echo "âœ… Database pod is Running (cluster condition may be updating)"
    else
      echo "âŒ Database pod is not running yet"
      echo "ğŸ’¡ Tip: Run 'mise run homelab:status' to check current status"
      exit 1
    fi
  fi
"""

# Migrations are now run automatically on backend startup (see backend/internal/migrate)

[tasks."homelab:status"]
description = "Show status of all services"
run = """
echo "=== Knative Services ==="
kubectl get ksvc -n ${NAMESPACE}
echo ""
echo "=== PostgreSQL Cluster ==="
kubectl get cluster -n ${NAMESPACE}
echo ""
echo "=== Pods ==="
kubectl get pods -n ${NAMESPACE}
"""

[tasks."homelab:backend:logs"]
description = "View backend logs"
run = "kubectl logs -n ${NAMESPACE} -l serving.knative.dev/service=${BACKEND_SERVICE} --tail=100 -f"

[tasks."homelab:frontend:logs"]
description = "View frontend logs"
run = "kubectl logs -n ${NAMESPACE} -l serving.knative.dev/service=${FRONTEND_SERVICE} --tail=100 -f"

[tasks."homelab:backend:url"]
description = "Get backend URL"
run = "kn service describe ${BACKEND_SERVICE} -n ${NAMESPACE} -o url"

[tasks."homelab:frontend:url"]
description = "Get frontend URL"
run = "kn service describe ${FRONTEND_SERVICE} -n ${NAMESPACE} -o url"

[tasks."homelab:backend:delete"]
description = "Delete backend service"
run = "kubectl delete -f ${DEPLOY_DIR}/knative-service-backend.yaml"

[tasks."homelab:frontend:delete"]
description = "Delete frontend service"
run = "kubectl delete -f ${DEPLOY_DIR}/knative-service-frontend.yaml"

[tasks."homelab:delete"]
description = "Delete all services"
run = """
kubectl delete ksvc -n ${NAMESPACE} --all
echo "âœ… All services deleted"
echo "ğŸ’¡ To delete namespace: kubectl delete namespace ${NAMESPACE}"
"""

[tasks."homelab:clean"]
description = "Clean build artifacts"
run = """
rm -f .build-tag-backend .build-tag-frontend
rm -rf ${BACKEND_DIR}/bin
rm -rf ${FRONTEND_DIR}/out ${FRONTEND_DIR}/.next
echo "âœ… Build artifacts cleaned"
"""
