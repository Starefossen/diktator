[tools]
go = "1.25"
node = "24"
opentofu = "latest"
air = "latest"
pnpm = "10"
"go:github.com/golangci/golangci-lint/cmd/golangci-lint" = "latest"
"go:golang.org/x/vuln/cmd/govulncheck" = "latest"
"go:github.com/securego/gosec/v2/cmd/gosec" = "latest"
"go:github.com/swaggo/swag/cmd/swag" = "latest"

# ============================================================================
# Environment Configuration
# ============================================================================
[env]
# Static configuration - same across all environments
DIKTATOR_APP_NAME = "diktator"
DIKTATOR_API_SERVICE_NAME = "diktator-api"

# Development environment defaults
TTS_PROJECT = "diktator-dev"
TTS_QUOTA_PROJECT = "diktator-app"
GIN_MODE = "debug"

# PostgreSQL configuration
DATABASE_URL = "postgresql://postgres:postgres@localhost:5432/diktator?sslmode=disable"
DATABASE_TEST_URL = "postgresql://postgres:postgres@localhost:5432/diktator_test?sslmode=disable"

# Authentication - mock mode for development
AUTH_MODE = "mock"
MOCK_USER_ID = "mock-user-12345"
MOCK_USER_EMAIL = "dev@localhost"
MOCK_USER_NAME = "Development User"

# Frontend configuration
NEXT_PUBLIC_API_URL = "http://localhost:8080"
NEXT_PUBLIC_AUTH_MODE = "mock"
NEXT_TELEMETRY_DISABLED = "1"
NODE_ENV = "development"

# Port configuration
BACKEND_PORT = "8080"
FRONTEND_PORT = "3000"

# Docker Compose configuration
DOCKER_COMPOSE_FILE = "docker-compose.dev.yml"

# Wait times (in seconds)
DB_STARTUP_WAIT = "3"
BACKEND_STARTUP_WAIT = "3"
BACKEND_STOP_WAIT = "1"
DB_RESET_WAIT = "5"

# Timeouts (kubectl wait)
POD_READY_TIMEOUT = "600s"
KNATIVE_READY_TIMEOUT = "300s"

# Directory paths
TMP_DIR = ".tmp"
BACKEND_DIR = "backend"
FRONTEND_DIR = "frontend"
TERRAFORM_DIR = "terraform"
DEPLOY_DIR = "deploy"

# Build configuration
TARGETARCH = "amd64"
TTS_CACHE_SIZE_MB = "15"

# Homelab deployment configuration
REGISTRY_URL = "registry.intern.flaatten.org:5000"
NAMESPACE = "diktator"
BACKEND_SERVICE = "api"
FRONTEND_SERVICE = "www"

# Homelab OIDC configuration
HOMELAB_API_URL = "https://api.diktator.fn.flaatten.org"
HOMELAB_APP_URL = "https://www.diktator.fn.flaatten.org"
HOMELAB_OIDC_ISSUER_URL = "https://zitadel.zitadel.fn.flaatten.org"
HOMELAB_OIDC_CLIENT_ID = "353809168672555052"

# ============================================================================
# Private Helper Tasks
# ============================================================================
# These tasks are prefixed with _ to mark them as internal utilities.
# They are not intended to be run directly by users.

[tasks._validate-env]
# Validates that required environment variables are set
description = "[Internal] Validate required environment variables"
run = """
REQUIRED_VARS="TTS_PROJECT TTS_QUOTA_PROJECT DATABASE_URL DATABASE_TEST_URL"
MISSING_VARS=""

for VAR in $REQUIRED_VARS; do
    if [ -z "${!VAR}" ]; then
        MISSING_VARS="$MISSING_VARS $VAR"
    fi
done

if [ -n "$MISSING_VARS" ]; then
    echo "‚ùå Missing required environment variables:$MISSING_VARS"
    exit 1
fi
"""

[tasks._docker-compose]
# Wrapper for docker compose commands using the configured file
description = "[Internal] Run docker compose with configured file"
run = "docker compose -f ${DOCKER_COMPOSE_FILE} $@"

[tasks._ensure-postgres]
# Ensures PostgreSQL is running, starts it if not
description = "[Internal] Ensure PostgreSQL is running"
run = """
if ! docker compose -f ${DOCKER_COMPOSE_FILE} ps postgres 2>/dev/null | grep -q "running"; then
    echo "üêò Starting PostgreSQL..."
    docker compose -f ${DOCKER_COMPOSE_FILE} up -d postgres
    sleep ${DB_STARTUP_WAIT}
fi
"""

[tasks._wait-postgres]
# Waits for PostgreSQL to be ready to accept connections
description = "[Internal] Wait for PostgreSQL to be ready"
depends = ["_ensure-postgres"]
run = """
echo "‚è≥ Waiting for PostgreSQL to be ready..."
sleep ${DB_STARTUP_WAIT}
"""

[tasks._ensure-config]
# Ensures development configuration files exist
description = "[Internal] Ensure development config files exist"
run = """
if [ ! -f ${BACKEND_DIR}/.env.development ]; then
    echo "üìù Generating development config..."
    mise run config:dev
fi
"""

[tasks._load-dev-env]
# Loads development environment variables into current shell context
description = "[Internal] Load development environment variables"
depends = ["_ensure-config"]
dir = "backend"
run = "set -a && source .env.development && set +a"

[tasks._wait-backend]
# Waits for backend to be ready to accept connections
description = "[Internal] Wait for backend to be ready"
run = """
echo "‚è≥ Waiting for backend to be ready..."
sleep ${BACKEND_STARTUP_WAIT}
"""

# ============================================================================
# Development Tasks
# ============================================================================

[tasks.install]
description = "Install all dependencies"
run = """
echo "üì¶ Installing dependencies..."
(cd ${FRONTEND_DIR} && pnpm install) &
(cd ${BACKEND_DIR} && go mod tidy) &
wait
echo "‚úÖ All dependencies installed"
"""

[tasks.dev]
description = "Start full development environment (PostgreSQL + frontend + backend)"
depends = ["_ensure-config", "_ensure-postgres"]
run = """
echo "üöÄ Starting full development environment..."

# Ensure dependencies are installed
if [ ! -d ${FRONTEND_DIR}/node_modules ] || [ ! -f ${BACKEND_DIR}/go.sum ]; then
    echo "üì¶ Installing dependencies..."
    mise run install
fi

# Start backend with air (hot reload) in background
echo "üîß Starting backend with hot reload..."
cd ${BACKEND_DIR} && set -a && source .env.development && set +a && air &
BACKEND_PID=$!
sleep ${BACKEND_STARTUP_WAIT}

# Check if backend started successfully
if ! kill -0 $BACKEND_PID 2>/dev/null; then
    echo "‚ùå Backend failed to start"
    exit 1
fi

echo "‚úÖ Backend started (PID: $BACKEND_PID)"

# Start frontend
echo "‚öõÔ∏è  Starting frontend..."
cd ${FRONTEND_DIR} && cp .env.development .env.local && pnpm run dev

# Cleanup on exit
cleanup() {
    echo ""
    echo "üõë Stopping services..."
    kill $BACKEND_PID 2>/dev/null || true
    docker compose -f ${DOCKER_COMPOSE_FILE} down
}
trap cleanup EXIT INT TERM
"""

[tasks."frontend:dev"]
description = "Start frontend development server"
depends = ["_ensure-config"]
dir = "frontend"
run = """
cp .env.development .env.local
pnpm run dev
"""

[tasks."backend:dev"]
description = "Start backend with hot reload (air)"
depends = ["_ensure-config"]
dir = "backend"
run = """
set -a && source .env.development && set +a && air
"""

# ============================================================================
# Backend Service Management
# ============================================================================

[tasks."backend:start"]
description = "Start backend in background"
depends = ["_ensure-config", "_ensure-postgres"]
run = """
mkdir -p ${TMP_DIR}

if [ -f ${TMP_DIR}/backend.pid ] && kill -0 $(cat ${TMP_DIR}/backend.pid) 2>/dev/null; then
    echo "‚ö†Ô∏è  Backend already running (PID: $(cat ${TMP_DIR}/backend.pid))"
    exit 0
fi

echo "üöÄ Starting backend..."
cd ${BACKEND_DIR}
set -a && source .env.development && set +a
nohup go run cmd/server/main.go > ../${TMP_DIR}/backend.log 2>&1 &
echo $! > ../${TMP_DIR}/backend.pid
cd ..

sleep ${BACKEND_STARTUP_WAIT}
if kill -0 $(cat ${TMP_DIR}/backend.pid) 2>/dev/null; then
    echo "‚úÖ Backend started (PID: $(cat ${TMP_DIR}/backend.pid))"
    echo "   Logs: ${TMP_DIR}/backend.log"
    curl -s http://localhost:${BACKEND_PORT}/health | head -c 100
    echo ""
else
    echo "‚ùå Backend failed to start"
    tail -20 ${TMP_DIR}/backend.log
    exit 1
fi
"""

[tasks."backend:stop"]
description = "Stop backend"
run = """
if [ -f ${TMP_DIR}/backend.pid ]; then
    PID=$(cat ${TMP_DIR}/backend.pid)
    if kill -0 $PID 2>/dev/null; then
        echo "Stopping backend (PID: $PID)..."
        kill $PID
        sleep ${BACKEND_STOP_WAIT}
        kill -0 $PID 2>/dev/null && kill -9 $PID
        echo "‚úÖ Backend stopped"
    fi
    rm -f ${TMP_DIR}/backend.pid
else
    lsof -ti:${BACKEND_PORT} | xargs kill -9 2>/dev/null || true
fi
"""

[tasks."backend:logs"]
description = "View backend logs"
run = """
if [ -f ${TMP_DIR}/backend.log ]; then
    tail -f ${TMP_DIR}/backend.log
else
    echo "No log file found. Start backend with 'mise run backend:start'"
fi
"""

[tasks."backend:status"]
description = "Check backend status"
run = """
if [ -f ${TMP_DIR}/backend.pid ] && kill -0 $(cat ${TMP_DIR}/backend.pid) 2>/dev/null; then
    echo "‚úÖ Backend running (PID: $(cat ${TMP_DIR}/backend.pid))"
    curl -s http://localhost:${BACKEND_PORT}/health 2>/dev/null || echo "‚ùå Not responding"
else
    echo "‚ùå Backend not running"
fi
"""

[tasks."backend:restart"]
description = "Restart backend"
run = "mise run backend:stop && sleep ${BACKEND_STOP_WAIT} && mise run backend:start"

# ============================================================================
# Database Tasks
# ============================================================================

[tasks."db:start"]
description = "Start PostgreSQL"
run = """
docker compose -f ${DOCKER_COMPOSE_FILE} up -d
echo "PostgreSQL started at localhost:5432"
"""

[tasks."db:stop"]
description = "Stop PostgreSQL"
run = "docker compose -f ${DOCKER_COMPOSE_FILE} down"

[tasks."db:reset"]
description = "Reset database (destroy and recreate)"
run = """
echo "WARNING: This will delete all data!"
read -p "Are you sure? (y/N): " -n 1 -r
echo
if [[ $REPLY =~ ^[Yy]$ ]]; then
    docker compose -f ${DOCKER_COMPOSE_FILE} down -v
    docker compose -f ${DOCKER_COMPOSE_FILE} up -d
    echo "‚úÖ Database reset complete. Migrations will run on next backend start."
fi
"""

[tasks."db:reset-force"]
description = "Reset database without confirmation (use with caution)"
run = """
echo "‚ö†Ô∏è  Force resetting database..."
docker compose -f ${DOCKER_COMPOSE_FILE} down -v
docker compose -f ${DOCKER_COMPOSE_FILE} up -d
echo "‚úÖ Database reset complete. Migrations will run on next backend start."
"""

# Migrations now run automatically on backend startup (see backend/internal/migrate)

[tasks."db:reset-test"]
description = "Reset test database (destroy and recreate)"
run = """
echo "Resetting test database..."
docker compose -f ${DOCKER_COMPOSE_FILE} exec -T postgres psql -U postgres -c "DROP DATABASE IF EXISTS diktator_test;"
docker compose -f ${DOCKER_COMPOSE_FILE} exec -T postgres psql -U postgres -c "CREATE DATABASE diktator_test;"
echo "‚úÖ Test database reset complete. Migrations will run on next test."
"""

[tasks."db:shell"]
description = "Open PostgreSQL shell"
run = "docker compose -f ${DOCKER_COMPOSE_FILE} exec postgres psql -U postgres -d diktator"

[tasks."db:seed"]
description = "Seed database with test data"
dir = "backend"
run = """
echo "üå± Seeding database with test data..."
go run cmd/seed/main.go
"""

[tasks."db:reset-seed"]
description = "Reset database and seed with fresh test data"
run = """
echo "üîÑ Resetting database..."
mise run db:reset-force

echo "‚è≥ Waiting for database..."
sleep ${DB_RESET_WAIT}

echo "üå± Seeding test data..."
mise run db:seed

echo "‚úÖ Database reset and seeded!"
"""

# ============================================================================
# Code Quality
# ============================================================================

[tasks.lint]
description = "Run linters (golangci-lint + ESLint)"
run = """
(cd ${FRONTEND_DIR} && pnpm run lint) &
(cd ${BACKEND_DIR} && golangci-lint run ./...) &
wait
"""

[tasks."backend:lint"]
description = "Run Go linting with golangci-lint"
dir = "backend"
run = "golangci-lint run ./..."

[tasks."backend:lint-fix"]
description = "Run Go linting with auto-fix"
dir = "backend"
run = "golangci-lint run --fix ./..."

[tasks."backend:security"]
description = "Run security scans (gosec + govulncheck)"
dir = "backend"
run = """
echo "üîí Running security scans..."
echo ""
echo "üìã Scanning for vulnerabilities in dependencies..."
govulncheck ./...
echo ""
echo "üîç Scanning for security issues in code..."
gosec -quiet ./...
echo ""
echo "‚úÖ Security scans complete"
"""

[tasks."backend:race"]
description = "Run tests with race detector"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "üèÉ Running tests with race detector..."
DATABASE_URL="${DATABASE_TEST_URL}" go test -race ./...
"""

[tasks.format]
description = "Format code"
run = """
(cd ${FRONTEND_DIR} && pnpm run format) &
(cd ${BACKEND_DIR} && go fmt ./...) &
(cd ${TERRAFORM_DIR} && tofu fmt) &
wait
"""

[tasks.typecheck]
description = "Type check all code"
run = """
(cd ${FRONTEND_DIR} && pnpm run typecheck) &
(cd ${BACKEND_DIR} && go build -o /dev/null ./...) &
wait
"""

[tasks."frontend:knip"]
description = "Find unused code in frontend"
dir = "frontend"
run = "pnpm run knip"

[tasks."frontend:knip-fix"]
description = "Auto-fix unused code in frontend"
dir = "frontend"
run = "pnpm run knip:fix"

[tasks."frontend:i18n-check"]
description = "Check for unused/missing i18n translation keys"
dir = "frontend"
run = "pnpm run i18n:check"

[tasks."frontend:check"]
description = "Run all frontend checks (typecheck, lint:fix, format, knip:fix, test) with auto-fixing"
dir = "frontend"
run = "pnpm run check"

[tasks."frontend:build"]
description = "Build frontend for production"
dir = "frontend"
run = """
cp .env.production .env.local 2>/dev/null || true
NODE_ENV=production pnpm run build
"""

[tasks."backend:check"]
description = "Run all backend checks (fmt, lint, test, security) with auto-fixing"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "üîß Running backend checks..."
echo ""
echo "üìù Formatting code..."
go fmt ./...

echo ""
echo "üîç Running golangci-lint..."
golangci-lint run --fix ./...

echo ""
echo "üß™ Running tests..."
DATABASE_URL="${DATABASE_TEST_URL}" go test ./...

echo ""
echo "üîí Running security scans..."
govulncheck ./... 2>&1 | head -20 || echo "‚ö†Ô∏è  Vulnerabilities found - run 'mise run backend:security' for details"

echo ""
echo "‚úÖ All backend checks passed!"
"""

[tasks.test]
description = "Run all tests (lint + typecheck + backend + frontend unit tests)"
depends = ["_ensure-postgres"]
run = """
echo "üß™ Running all tests..."

echo ""
echo "üìã Running linters..."
mise run lint &
LINT_PID=$!

echo ""
echo "üîç Type checking..."
mise run typecheck &
TYPE_PID=$!

wait $LINT_PID $TYPE_PID

echo ""
echo "üîß Backend tests..."
(cd ${BACKEND_DIR} && DATABASE_URL="${DATABASE_TEST_URL}" go test ./...) &
BACKEND_PID=$!

echo ""
echo "‚öõÔ∏è  Frontend unit tests..."
(cd ${FRONTEND_DIR} && pnpm test) &
FRONTEND_PID=$!

wait $BACKEND_PID $FRONTEND_PID

echo ""
echo "‚úÖ All tests passed!"
"""

[tasks."test:unit"]
description = "Run unit tests only (backend + frontend, skip integration)"
run = """
echo "üß™ Running unit tests..."

echo ""
echo "üîß Backend unit tests..."
(cd ${BACKEND_DIR} && go test -short ./...) &

echo ""
echo "‚öõÔ∏è  Frontend unit tests..."
(cd ${FRONTEND_DIR} && pnpm test) &

wait

echo "‚úÖ Unit tests passed!"
"""

[tasks."test:integration"]
description = "Run integration tests only (backend with real PostgreSQL)"
depends = ["_ensure-postgres", "db:reset-test"]
run = """
echo "üß™ Running integration tests with real database..."
(cd ${BACKEND_DIR} && TEST_DATABASE_URL="${DATABASE_TEST_URL}" INTEGRATION_TESTS=true go test -v -run Integration ./handlers)
"""

[tasks."test:e2e"]
description = "Run end-to-end tests (Playwright - starts servers automatically)"
depends = ["_ensure-postgres"]
run = """
echo "üé≠ Running E2E tests..."
echo "Note: Playwright will start the frontend server automatically"
echo "      Backend will be started in background"
echo ""

# Create mock user in database if not exists (family and user must exist for tests)
(cd ${BACKEND_DIR} && set -a && source .env.development && set +a && \
psql "${DATABASE_URL}" <<'SQL'
-- Insert user first without family_id
INSERT INTO users (id, auth_id, email, display_name, family_id, role, is_active, created_at, last_active_at)
VALUES ('mock-user-12345', 'mock-user-12345', 'dev@localhost', 'Development User', NULL, 'parent', true, NOW(), NOW())
ON CONFLICT (id) DO NOTHING;

-- Insert family with the user as creator
INSERT INTO families (id, name, created_by, created_at, updated_at)
VALUES ('family-mock-user-12345', 'Development Family', 'mock-user-12345', NOW(), NOW())
ON CONFLICT (id) DO NOTHING;

-- Update user with family_id
UPDATE users SET family_id = 'family-mock-user-12345' WHERE id = 'mock-user-12345' AND family_id IS NULL;

-- Insert family member relationship
INSERT INTO family_members (family_id, user_id, joined_at)
VALUES ('family-mock-user-12345', 'mock-user-12345', NOW())
ON CONFLICT (family_id, user_id) DO NOTHING;
SQL
) > /dev/null 2>&1 && echo "‚úÖ Mock user ready" || echo "‚ö†Ô∏è  Database setup had issues"

# Start backend in background for the test
(cd ${BACKEND_DIR} && set -a && source .env.development && set +a && go run cmd/server/main.go) > /tmp/e2e-backend.log 2>&1 &
BACKEND_PID=$!
echo "‚è≥ Waiting for backend to start..."
sleep 5

# Check if backend started
if ! curl -s http://localhost:${BACKEND_PORT}/health > /dev/null 2>&1; then
    echo "‚ùå Backend failed to start"
    kill $BACKEND_PID 2>/dev/null || true
    exit 1
fi

echo "‚úÖ Backend ready"

# Run tests (Playwright will start frontend via webServer config)
(cd ${FRONTEND_DIR} && HEADLESS=1 pnpm exec playwright test)

# Cleanup
TEST_EXIT=$?
kill $BACKEND_PID 2>/dev/null || true
exit $TEST_EXIT
"""

[tasks."backend:test"]
description = "Run backend tests"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "üîß Running backend tests..."
DATABASE_URL="${DATABASE_TEST_URL}" go test -v ./...
"""

[tasks."backend:test-short"]
description = "Run backend tests without integration tests"
dir = "backend"
run = "go test -short -v ./..."

[tasks."backend:test-integration"]
description = "Run backend integration tests only (requires PostgreSQL)"
depends = ["_ensure-postgres", "db:reset-test"]
dir = "backend"
run = """
echo "üß™ Running integration tests with real database..."
TEST_DATABASE_URL="${DATABASE_TEST_URL}" INTEGRATION_TESTS=true go test -v -run Integration ./handlers
"""

[tasks."backend:test-coverage"]
description = "Run backend tests with coverage"
depends = ["_ensure-postgres"]
dir = "backend"
run = """
echo "üîß Running backend tests with coverage..."
DATABASE_URL="${DATABASE_TEST_URL}" go test -coverprofile=coverage.out ./...
go tool cover -html=coverage.out -o coverage.html
echo "‚úÖ Coverage report: backend/coverage.html"
"""

[tasks."frontend:test"]
description = "Run frontend unit tests"
dir = "frontend"
run = "pnpm test"

[tasks."frontend:test-watch"]
description = "Run frontend tests in watch mode"
dir = "frontend"
run = "pnpm test:watch"

[tasks."frontend:test-coverage"]
description = "Run frontend tests with coverage"
dir = "frontend"
run = "pnpm test:coverage"

[tasks."frontend:test-e2e"]
description = "Run frontend E2E tests with Playwright"
dir = "frontend"
run = """
echo "üé≠ Running E2E tests..."

# Check if backend is running
if ! curl -s http://localhost:${BACKEND_PORT}/health > /dev/null 2>&1; then
    echo "‚ö†Ô∏è  Backend not running. Starting backend..."
    mise run backend:start
    sleep ${BACKEND_STARTUP_WAIT}
fi

pnpm test:e2e
"""

[tasks."frontend:test-e2e-ui"]
description = "Run E2E tests with Playwright UI"
dir = "frontend"
run = """
# Check if backend is running
if ! curl -s http://localhost:${BACKEND_PORT}/health > /dev/null 2>&1; then
    echo "‚ö†Ô∏è  Backend not running. Starting backend..."
    mise run backend:start
    sleep ${BACKEND_STARTUP_WAIT}
fi

pnpm test:e2e:ui
"""

[tasks."test:all"]
description = "Run complete test suite (unit + integration + E2E)"
depends = ["_ensure-postgres", "db:reset-test"]
run = """
echo "üß™ Running complete test suite..."

echo ""
echo "=== Unit Tests ==="
mise run test:unit

echo ""
echo "=== Integration Tests ==="
mise run test:integration

echo ""
echo "=== E2E Tests ==="
mise run test:e2e

echo ""
echo "‚úÖ All tests (unit + integration + E2E) passed!"
"""

[tasks.check]
description = "Run all checks (backend + frontend: fmt, lint, typecheck, knip, tests)"
depends = ["_ensure-postgres"]
run = """
echo "üîç Running all checks..."
echo ""

# Backend checks
echo "[backend] Running checks..."
cd ${BACKEND_DIR}
go fmt ./... > /dev/null 2>&1
golangci-lint run --fix ./... > /dev/null 2>&1 || true
govulncheck ./...
DATABASE_URL="${DATABASE_TEST_URL}" go test ./... || exit 1
echo "[backend] ‚úÖ Done"
echo ""

# Frontend checks
echo "[frontend] Running checks..."
cd ../${FRONTEND_DIR}
pnpm run check || exit 1
echo "[frontend] ‚úÖ Done"
echo ""

echo "‚úÖ All checks passed!"
"""

[tasks.fmt]
description = "Format code (alias for format)"
run = "mise run format"

# ============================================================================
# API Documentation
# ============================================================================

[tasks."backend:swagger-gen"]
description = "Generate OpenAPI spec"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum"]
outputs = ["docs/swagger.json", "docs/swagger.yaml", "docs/docs.go"]
run = """
command -v swag &>/dev/null || go install github.com/swaggo/swag/cmd/swag@latest
swag init -g cmd/server/main.go --output docs --parseInternal
echo "‚úÖ OpenAPI spec generated"
"""

[tasks."frontend:client-gen"]
description = "Generate TypeScript client"
dir = "frontend"
sources = ["../backend/docs/swagger.json"]
outputs = ["src/generated/**/*.ts"]
run = """
npx @openapitools/openapi-generator-cli generate \
    -i ../backend/docs/swagger.json \
    -g typescript-axios \
    -o src/generated \
    --additional-properties=supportsES6=true,withInterfaces=true
echo "‚úÖ TypeScript client generated"
"""

# ============================================================================
# Build Tasks
# ============================================================================

[tasks.build]
description = "Build for production"
run = """
mise run backend:swagger-gen
mise run config:prod
(cd ${FRONTEND_DIR} && cp .env.production .env.local && pnpm run build) &
(cd ${BACKEND_DIR} && go build -o bin/server cmd/server/main.go) &
wait
"""

[tasks."backend:build-binary"]
description = "Build backend binary for target architecture"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum"]
outputs = ["bin/server-linux-*"]
run = """
ARCH=${TARGETARCH}
echo "üî® Building backend binary for linux-${ARCH}..."
mkdir -p bin
CGO_ENABLED=0 GOOS=linux GOARCH=${ARCH} go build -ldflags="-w -s" -o bin/server-linux-${ARCH} ./cmd/server/main.go
echo "‚úÖ Binary built: backend/bin/server-linux-${ARCH}"
"""

[tasks."backend:docker-build"]
description = "Build backend Docker image (builds binary first)"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum", "Dockerfile"]
run = """
ARCH=${TARGETARCH}
echo "üì¶ Building backend Docker image for ${ARCH}..."

# Build binary outside Docker for performance
mise run backend:build-binary

# Build minimal Docker image with pre-built binary
docker build --build-arg TARGETARCH=${ARCH} -t diktator-api:latest -t diktator-api:${ARCH} .
echo "‚úÖ Built: diktator-api:latest (linux-${ARCH})"
"""

[tasks."frontend:docker-build"]
description = "Build frontend Docker image with nginx"
depends = ["frontend:config-homelab"]
dir = "frontend"
sources = [
  "src/**/*.{ts,tsx,js,jsx,json,css}",
  "package.json",
  "pnpm-lock.yaml",
  "Dockerfile",
  "nginx.conf",
]
run = """
echo "üì¶ Building frontend Docker image..."

# Build frontend first
cp .env.production .env.local 2>/dev/null || true
NODE_ENV=production pnpm run build

# Build minimal Docker image with nginx
docker build -t diktator-frontend:latest .
echo "‚úÖ Built: diktator-frontend:latest"
"""

[tasks.clean]
description = "Clean build artifacts"
run = """
mise run backend:stop 2>/dev/null || true
rm -rf ${FRONTEND_DIR}/.next ${FRONTEND_DIR}/out ${FRONTEND_DIR}/src/generated ${FRONTEND_DIR}/dist
rm -rf ${BACKEND_DIR}/bin
rm -f ${FRONTEND_DIR}/.env.local ${BACKEND_DIR}/.env.* ${FRONTEND_DIR}/.env.*
rm -f .mise.env
rm -rf ${TMP_DIR}
echo "‚úÖ Build artifacts cleaned"
"""

# ============================================================================
# Setup & Configuration
# ============================================================================

[tasks.setup]
description = "Initial project setup"
run = """
echo "üöÄ Setting up Diktator..."

echo ""
echo "üì¶ Installing tools..."
mise install

echo ""
echo "üìù Generating development config..."
mise run config:dev

echo ""
echo "üì¶ Installing dependencies..."
mise run install

echo ""
echo "üêò Starting PostgreSQL..."
docker compose -f ${DOCKER_COMPOSE_FILE} pull
docker compose -f ${DOCKER_COMPOSE_FILE} up -d
sleep ${DB_STARTUP_WAIT}

echo ""
echo "‚úÖ Setup complete!"
echo ""
echo "Next steps:"
echo "  Start full dev:     mise run dev"
echo "  Start backend only: mise run backend:start"
echo "  Start frontend:     mise run frontend:dev"
echo "  Run tests:          mise run test"
"""

[tasks."config:dev"]
description = "Generate development configuration"
depends = ["_validate-env"]
run = """
echo "üìù Generating development configuration..."
envsubst < ${BACKEND_DIR}/.env.development.tmpl > ${BACKEND_DIR}/.env.development
envsubst < ${FRONTEND_DIR}/.env.development.tmpl > ${FRONTEND_DIR}/.env.development
echo "‚úÖ Development config created"
"""

[tasks."config:prod"]
description = "Generate production configuration"
depends = ["_validate-env"]
run = """
if [ ! -f .mise.env ]; then
    echo "ERROR: .mise.env not found. Run 'mise run config:load' first."
    exit 1
fi
source .mise.env

echo "üìù Generating production configuration..."

# Note: Production config uses different variables than development
# Some vars like OIDC URLs need to be set in .mise.env before running this
cat > ${BACKEND_DIR}/.env.production << EOF
TTS_PROJECT=${DIKTATOR_PROJECT_ID}
TTS_QUOTA_PROJECT=${TTS_QUOTA_PROJECT:-${DIKTATOR_PROJECT_ID}}
GIN_MODE=release
PORT=8080
DATABASE_URL=${DATABASE_URL}
AUTH_MODE=oidc
OIDC_ISSUER_URL=${OIDC_ISSUER_URL:-https://auth.diktator.app}
OIDC_AUDIENCE=${OIDC_AUDIENCE:-diktator}
EOF

cat > ${FRONTEND_DIR}/.env.production << EOF
NEXT_PUBLIC_API_URL=${DIKTATOR_API_URL:-https://${DIKTATOR_API_SERVICE_NAME}-${DIKTATOR_REGION:-${DIKTATOR_DEFAULT_REGION}}.run.app}
NEXT_PUBLIC_AUTH_MODE=oidc
NEXT_PUBLIC_OIDC_ISSUER_URL=${OIDC_ISSUER_URL:-https://auth.diktator.app}
NEXT_PUBLIC_OIDC_CLIENT_ID=${OIDC_CLIENT_ID:-diktator-frontend}
NEXT_TELEMETRY_DISABLED=1
NODE_ENV=production
EOF

echo "‚úÖ Production config created"
"""

[tasks."config:load"]
description = "Load configuration from terraform"
dir = "terraform"
run = """
if [ ! -d .terraform ]; then
    echo "Terraform not initialized. Run 'mise run tofu:init'"
    exit 1
fi

cat > ../.mise.env << EOF
DIKTATOR_PROJECT_ID=$(tofu output -raw project_id 2>/dev/null || echo "")
EOF
echo "Configuration loaded to .mise.env"
"""

# ============================================================================
# Infrastructure (OpenTofu)
# ============================================================================

[tasks."tofu:init"]
description = "Initialize OpenTofu"
dir = "terraform"
run = "tofu init"

[tasks."tofu:plan"]
description = "Plan infrastructure changes"
dir = "terraform"
run = "tofu plan"

[tasks."tofu:apply"]
description = "Apply infrastructure"
dir = "terraform"
run = "tofu apply"

[tasks."tofu:destroy"]
description = "Destroy infrastructure"
dir = "terraform"
run = "tofu destroy"

[tasks."tofu:fmt"]
description = "Format terraform files"
dir = "terraform"
run = "tofu fmt"

# ============================================================================
# Homelab Deployment (Knative)
# ============================================================================

[tasks."homelab:backend:build"]
description = "Build backend binaries and Docker image for homelab"
dir = "backend"
sources = ["**/*.go", "go.mod", "go.sum", "Dockerfile"]
outputs = [
  "bin/server-linux-amd64",
  "bin/server-linux-arm64",
  "../.build-tag-backend",
]
run = """
echo "üî® Building backend binaries..."

# Build for linux/amd64
CGO_ENABLED=0 GOOS=linux GOARCH=amd64 go build -o bin/server-linux-amd64 ./cmd/server

# Build for linux/arm64
CGO_ENABLED=0 GOOS=linux GOARCH=arm64 go build -o bin/server-linux-arm64 ./cmd/server

echo "üì¶ Building and pushing Docker image..."
BUILD_TAG=$(date +%s)

# Build multi-arch image
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  --build-arg TARGETARCH=amd64 \
  -t ${REGISTRY_URL}/${BACKEND_SERVICE}:${BUILD_TAG} \
  --push \
  .

# Save build tag for deployment
echo ${BUILD_TAG} > ../.build-tag-backend
echo "‚úÖ Backend built: ${REGISTRY_URL}/${BACKEND_SERVICE}:${BUILD_TAG}"
"""

[tasks."frontend:config-homelab"]
description = "Generate frontend build configuration for homelab Knative deployment"
run = """
cat > ${FRONTEND_DIR}/.env.production << EOF
NEXT_PUBLIC_API_URL=${HOMELAB_API_URL}
NEXT_PUBLIC_APP_URL=${HOMELAB_APP_URL}
NEXT_PUBLIC_AUTH_MODE=oidc
NEXT_PUBLIC_OIDC_ISSUER_URL=${HOMELAB_OIDC_ISSUER_URL}
NEXT_PUBLIC_OIDC_CLIENT_ID=${HOMELAB_OIDC_CLIENT_ID}
NEXT_PUBLIC_OIDC_REDIRECT_URI=${HOMELAB_APP_URL}/auth/callback
NEXT_PUBLIC_OIDC_POST_LOGOUT_REDIRECT_URI=${HOMELAB_APP_URL}
NEXT_TELEMETRY_DISABLED=1
NODE_ENV=production
EOF
echo "‚úÖ Homelab config: ${FRONTEND_DIR}/.env.production"
"""

[tasks."homelab:frontend:build"]
description = "Build frontend and Docker image for homelab"
depends = ["frontend:config-homelab"]
dir = "frontend"
run = """
echo "üî® Building frontend static files..."
pnpm install
source .env.production
NODE_ENV=production pnpm run build

echo "üì¶ Building and pushing Docker image..."
BUILD_TAG=$(date +%s)

# Build multi-arch image
docker buildx build \
  --platform linux/amd64,linux/arm64 \
  -t ${REGISTRY_URL}/${FRONTEND_SERVICE}:${BUILD_TAG} \
  --push \
  .

# Save build tag for deployment
echo ${BUILD_TAG} > ../.build-tag-frontend
echo "‚úÖ Frontend built: ${REGISTRY_URL}/${FRONTEND_SERVICE}:${BUILD_TAG}"
"""

[tasks."homelab:build"]
description = "Build both backend and frontend for homelab"
depends = ["homelab:backend:build", "homelab:frontend:build"]

[tasks."homelab:gcp:export-credentials"]
description = "Export TTS credentials from Terraform"
dir = "terraform"
run = """
echo "üì• Exporting TTS service credentials..."

if [ ! -d ".terraform" ]; then
  echo "‚ùå Terraform not initialized. Run 'mise run tofu:init' first."
  exit 1
fi

if ! tofu output app_service_account_key >/dev/null 2>&1; then
  echo "‚ùå No service account found. Run 'mise run tofu:apply' first."
  exit 1
fi

tofu output -raw app_service_account_key | base64 -d > ../${DEPLOY_DIR}/gcp-credentials.json
echo "‚úÖ Credentials exported to ${DEPLOY_DIR}/gcp-credentials.json"
"""

[tasks."homelab:gcp:create-secret"]
description = "Create Kubernetes secret for TTS credentials"
depends = ["homelab:namespace:create", "homelab:gcp:export-credentials"]
run = """
if [ ! -f "${DEPLOY_DIR}/gcp-credentials.json" ]; then
  echo "‚ùå Credentials file not found. Run 'mise run homelab:gcp:export-credentials' first."
  exit 1
fi

echo "üîê Creating Kubernetes secret..."

# Delete existing secret if it exists
kubectl delete secret gcp-credentials -n ${NAMESPACE} 2>/dev/null || true

# Create new secret
kubectl create secret generic gcp-credentials \
  --from-file=key.json=${DEPLOY_DIR}/gcp-credentials.json \
  -n ${NAMESPACE}

# Delete credentials file from disk
rm -f ${DEPLOY_DIR}/gcp-credentials.json

echo "‚úÖ Secret 'gcp-credentials' created in namespace ${NAMESPACE}"
echo "üóëÔ∏è  Credentials file removed from disk"
"""

[tasks."homelab:namespace:create"]
description = "Create namespace if it doesn't exist"
run = """
if ! kubectl get namespace ${NAMESPACE} >/dev/null 2>&1; then
  kubectl create namespace ${NAMESPACE}
  echo "‚úÖ Created namespace: ${NAMESPACE}"
else
  echo "‚úì Namespace ${NAMESPACE} already exists"
fi
"""

[tasks."homelab:network:apply"]
description = "Apply Cilium network policies"
depends = ["homelab:namespace:create"]
run = """
echo "üîí Applying network policies..."
kubectl apply -f ${DEPLOY_DIR}/networkpolicy.yaml
echo "‚úÖ Network policies applied"
"""

[tasks."homelab:backend:deploy"]
description = "Deploy backend to Knative"
depends = ["homelab:gcp:create-secret"]
run = """
if [ ! -f ".build-tag-backend" ]; then
  echo "‚ùå No build tag found. Run 'mise run homelab:backend:build' first."
  exit 1
fi

BUILD_TAG=$(cat .build-tag-backend)

echo "üöÄ Deploying backend: ${BACKEND_SERVICE}:${BUILD_TAG}"

# Update image tag in manifest
sed "s|BUILD_TAG|${BUILD_TAG}|" \
  ${DEPLOY_DIR}/knative-service-backend.yaml | kubectl apply -f -

echo "‚è≥ Waiting for backend to be ready..."
kubectl wait --for=condition=Ready \
  --timeout=${KNATIVE_READY_TIMEOUT} \
  -n ${NAMESPACE} \
  ksvc/${BACKEND_SERVICE}

echo "‚úÖ Backend deployed successfully"
"""

[tasks."homelab:frontend:deploy"]
description = "Deploy frontend to Knative"
run = """
if [ ! -f ".build-tag-frontend" ]; then
  echo "‚ùå No build tag found. Run 'mise run homelab:frontend:build' first."
  exit 1
fi

BUILD_TAG=$(cat .build-tag-frontend)

echo "üöÄ Deploying frontend: ${FRONTEND_SERVICE}:${BUILD_TAG}"

# Update image tag in manifest
sed "s|BUILD_TAG|${BUILD_TAG}|" \
  ${DEPLOY_DIR}/knative-service-frontend.yaml | kubectl apply -f -

echo "‚è≥ Waiting for frontend to be ready..."
kubectl wait --for=condition=Ready \
  --timeout=${KNATIVE_READY_TIMEOUT} \
  -n ${NAMESPACE} \
  ksvc/${FRONTEND_SERVICE}

echo "‚úÖ Frontend deployed successfully"
"""

[tasks."homelab:deploy"]
description = "Deploy both backend and frontend to homelab"
depends = [
  "homelab:namespace:create",
  "homelab:gcp:create-secret",
  "homelab:network:apply",
  "homelab:backend:deploy",
  "homelab:frontend:deploy",
]

[tasks."homelab:deploy:full"]
description = "Build and deploy both services to homelab"
depends = ["homelab:build", "homelab:deploy"]

[tasks."homelab:db:create"]
description = "Create PostgreSQL database"
depends = ["homelab:namespace:create"]
run = """
echo "üìä Creating database..."
kubectl apply -f ${DEPLOY_DIR}/postgres-cluster.yaml

echo "‚è≥ Waiting for database pod to be ready (this may take 2-5 minutes)..."

# Wait for pods to be ready (more reliable than cluster condition)
if kubectl wait --for=condition=Ready \
  --timeout=${POD_READY_TIMEOUT} \
  -n ${NAMESPACE} \
  pod -l cnpg.io/cluster=diktator-db 2>/dev/null; then
  echo "‚úÖ Database pod is ready"
else
    echo "‚ö†Ô∏è  Pod readiness check failed. Verifying cluster status..."

    # Check if cluster resource exists and its conditions
    echo "üìã Cluster status:"
    kubectl get cluster diktator-db -n ${NAMESPACE} -o wide
    echo ""
    echo "üìã Cluster conditions:"
    kubectl get cluster diktator-db -n ${NAMESPACE} -o jsonpath='{.status.conditions[*]}' | jq . 2>/dev/null || true
    echo ""

    # Check pod status directly
    echo "üìã PostgreSQL pod status:"
    kubectl get pods -n ${NAMESPACE} -l cnpg.io/cluster=diktator-db
    echo ""

    # If pod exists and is running, consider it success despite timeout
    if kubectl get pods -n ${NAMESPACE} -l cnpg.io/cluster=diktator-db -o jsonpath='{.items[0].status.phase}' 2>/dev/null | grep -q Running; then
      echo "‚úÖ Database pod is Running (cluster condition may be updating)"
    else
      echo "‚ùå Database pod is not running yet"
      echo "üí° Tip: Run 'mise run homelab:status' to check current status"
      exit 1
    fi
  fi
"""

# Migrations are now run automatically on backend startup (see backend/internal/migrate)

[tasks."homelab:status"]
description = "Show status of all services"
run = """
echo "=== Knative Services ==="
kubectl get ksvc -n ${NAMESPACE}
echo ""
echo "=== PostgreSQL Cluster ==="
kubectl get cluster -n ${NAMESPACE}
echo ""
echo "=== Pods ==="
kubectl get pods -n ${NAMESPACE}
"""

[tasks."homelab:backend:logs"]
description = "View backend logs"
run = "kubectl logs -n ${NAMESPACE} -l serving.knative.dev/service=${BACKEND_SERVICE} --tail=100 -f"

[tasks."homelab:frontend:logs"]
description = "View frontend logs"
run = "kubectl logs -n ${NAMESPACE} -l serving.knative.dev/service=${FRONTEND_SERVICE} --tail=100 -f"

[tasks."homelab:backend:url"]
description = "Get backend URL"
run = "kn service describe ${BACKEND_SERVICE} -n ${NAMESPACE} -o url"

[tasks."homelab:frontend:url"]
description = "Get frontend URL"
run = "kn service describe ${FRONTEND_SERVICE} -n ${NAMESPACE} -o url"

[tasks."homelab:backend:delete"]
description = "Delete backend service"
run = "kubectl delete -f ${DEPLOY_DIR}/knative-service-backend.yaml"

[tasks."homelab:frontend:delete"]
description = "Delete frontend service"
run = "kubectl delete -f ${DEPLOY_DIR}/knative-service-frontend.yaml"

[tasks."homelab:delete"]
description = "Delete all services"
run = """
kubectl delete ksvc -n ${NAMESPACE} --all
echo "‚úÖ All services deleted"
echo "üí° To delete namespace: kubectl delete namespace ${NAMESPACE}"
"""

[tasks."homelab:clean"]
description = "Clean build artifacts"
run = """
rm -f .build-tag-backend .build-tag-frontend
rm -rf ${BACKEND_DIR}/bin
rm -rf ${FRONTEND_DIR}/out ${FRONTEND_DIR}/.next
echo "‚úÖ Build artifacts cleaned"
"""
